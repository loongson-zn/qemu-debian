<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: Sorting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01600.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Sorting<div class="ingroups"><a class="el" href="a01597.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Sorting:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01600.svg" width="371" height="131"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a01602" id="r_a01602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01602.html">Binary Search</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01621" id="r_a01621"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html">Heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01601" id="r_a01601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01601.html">Set Operations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga927cfd3e8df8c15df3fcec6c2af59a82" id="r_ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga927cfd3e8df8c15df3fcec6c2af59a82">std::clamp</a> (const _Tp &amp;__val, const _Tp &amp;<a class="el" href="a09261.html">__lo</a>, const _Tp &amp;<a class="el" href="a09261.html">__hi</a>)</td></tr>
<tr class="separator:ga927cfd3e8df8c15df3fcec6c2af59a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e7d39a4bbac23967d87e1dbd763e1e" id="r_ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga00e7d39a4bbac23967d87e1dbd763e1e">std::clamp</a> (const _Tp &amp;__val, const _Tp &amp;<a class="el" href="a09261.html">__lo</a>, const _Tp &amp;<a class="el" href="a09261.html">__hi</a>, _Compare __comp)</td></tr>
<tr class="separator:ga00e7d39a4bbac23967d87e1dbd763e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5479e1ac5e92b0c1f77bcf762d07e9" id="r_ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </td></tr>
<tr class="memitem:ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga5e5479e1ac5e92b0c1f77bcf762d07e9">std::inplace_merge</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __middle, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last)</td></tr>
<tr class="separator:ga5e5479e1ac5e92b0c1f77bcf762d07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6a8379ab8a648fd05d52ed0632081fa" id="r_gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gaf6a8379ab8a648fd05d52ed0632081fa">std::inplace_merge</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __middle, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gaf6a8379ab8a648fd05d52ed0632081fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a18da5fbc7d6f2b56f43156e13d02d2" id="r_ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga3a18da5fbc7d6f2b56f43156e13d02d2">std::is_sorted</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:ga3a18da5fbc7d6f2b56f43156e13d02d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2dd5c04be65e5bf5419776aeac1eda2" id="r_gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gae2dd5c04be65e5bf5419776aeac1eda2">std::is_sorted</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gae2dd5c04be65e5bf5419776aeac1eda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1373b346c799069f5c45c05993aeaf7f" id="r_ga1373b346c799069f5c45c05993aeaf7f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:ga1373b346c799069f5c45c05993aeaf7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga1373b346c799069f5c45c05993aeaf7f">std::is_sorted_until</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:ga1373b346c799069f5c45c05993aeaf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8cc41416bcbf277d408aa81bf1f051" id="r_ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga1e8cc41416bcbf277d408aa81bf1f051">std::is_sorted_until</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga1e8cc41416bcbf277d408aa81bf1f051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eff9effc89d8fd28bce9a6951b81f5d" id="r_ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II2</a> &gt; </td></tr>
<tr class="memitem:ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga8eff9effc89d8fd28bce9a6951b81f5d">std::lexicographical_compare</a> (<a class="el" href="a09261.html">_II1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_II1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_II2</a> <a class="el" href="a09261.html">__first2</a>, <a class="el" href="a09261.html">_II2</a> <a class="el" href="a09261.html">__last2</a>)</td></tr>
<tr class="separator:ga8eff9effc89d8fd28bce9a6951b81f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd54bcbe68e78e8751c700263ae6ef5" id="r_ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II2</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga9cd54bcbe68e78e8751c700263ae6ef5">std::lexicographical_compare</a> (<a class="el" href="a09261.html">_II1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_II1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_II2</a> <a class="el" href="a09261.html">__first2</a>, <a class="el" href="a09261.html">_II2</a> <a class="el" href="a09261.html">__last2</a>, _Compare __comp)</td></tr>
<tr class="separator:ga9cd54bcbe68e78e8751c700263ae6ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab98f0838f871a26317aaa71211b65a9c" id="r_gab98f0838f871a26317aaa71211b65a9c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gab98f0838f871a26317aaa71211b65a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gab98f0838f871a26317aaa71211b65a9c">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gab98f0838f871a26317aaa71211b65a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd491cbbfc0452492f8fe4b7c3760b0d" id="r_gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gacd491cbbfc0452492f8fe4b7c3760b0d">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:gacd491cbbfc0452492f8fe4b7c3760b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf8e17bbc480ed6676ec0d1a326f4a05" id="r_gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gacf8e17bbc480ed6676ec0d1a326f4a05">std::max_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:gacf8e17bbc480ed6676ec0d1a326f4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672a1736a849c3f4675f4c13a3068884" id="r_ga672a1736a849c3f4675f4c13a3068884"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga672a1736a849c3f4675f4c13a3068884"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga672a1736a849c3f4675f4c13a3068884">std::max_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga672a1736a849c3f4675f4c13a3068884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d39bebd559751b145e409dd2e41ab1d" id="r_ga0d39bebd559751b145e409dd2e41ab1d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </td></tr>
<tr class="memitem:ga0d39bebd559751b145e409dd2e41ab1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga0d39bebd559751b145e409dd2e41ab1d">std::merge</a> (<a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_InputIterator2</a> <a class="el" href="a09261.html">__first2</a>, <a class="el" href="a09261.html">_InputIterator2</a> <a class="el" href="a09261.html">__last2</a>, _OutputIterator __result)</td></tr>
<tr class="separator:ga0d39bebd559751b145e409dd2e41ab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d075968551b0f77f71052e8832a5b88" id="r_ga7d075968551b0f77f71052e8832a5b88"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga7d075968551b0f77f71052e8832a5b88"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga7d075968551b0f77f71052e8832a5b88">std::merge</a> (<a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_InputIterator2</a> <a class="el" href="a09261.html">__first2</a>, <a class="el" href="a09261.html">_InputIterator2</a> <a class="el" href="a09261.html">__last2</a>, _OutputIterator __result, _Compare __comp)</td></tr>
<tr class="separator:ga7d075968551b0f77f71052e8832a5b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cf068dc91c8779040669efa4a8cf65" id="r_gae9cf068dc91c8779040669efa4a8cf65"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gae9cf068dc91c8779040669efa4a8cf65"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gae9cf068dc91c8779040669efa4a8cf65">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gae9cf068dc91c8779040669efa4a8cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7909b7a198cc9c418432b4b2b138cac1" id="r_ga7909b7a198cc9c418432b4b2b138cac1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga7909b7a198cc9c418432b4b2b138cac1"><td class="memTemplItemLeft" align="right" valign="top">constexpr const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga7909b7a198cc9c418432b4b2b138cac1">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:ga7909b7a198cc9c418432b4b2b138cac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc18030e0f9d1b83be2e8f0718fe72c" id="r_ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga1bc18030e0f9d1b83be2e8f0718fe72c">std::min_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:ga1bc18030e0f9d1b83be2e8f0718fe72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c580be620f774d1b197c9db950b42ce" id="r_ga0c580be620f774d1b197c9db950b42ce"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga0c580be620f774d1b197c9db950b42ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga0c580be620f774d1b197c9db950b42ce">std::min_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga0c580be620f774d1b197c9db950b42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02c72c1390894648ba6d61ab8990db6" id="r_gae02c72c1390894648ba6d61ab8990db6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gae02c72c1390894648ba6d61ab8990db6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08457.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gae02c72c1390894648ba6d61ab8990db6">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b)</td></tr>
<tr class="separator:gae02c72c1390894648ba6d61ab8990db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98dfb06baec2f6d60027e169853a05d" id="r_gad98dfb06baec2f6d60027e169853a05d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gad98dfb06baec2f6d60027e169853a05d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08457.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gad98dfb06baec2f6d60027e169853a05d">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)</td></tr>
<tr class="separator:gad98dfb06baec2f6d60027e169853a05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857a1caf7ea9852c57b953b919eb1216" id="r_ga857a1caf7ea9852c57b953b919eb1216"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:ga857a1caf7ea9852c57b953b919eb1216"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_ForwardIterator</a>, <a class="el" href="a09261.html">_ForwardIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga857a1caf7ea9852c57b953b919eb1216">std::minmax_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:ga857a1caf7ea9852c57b953b919eb1216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6cf1edaccccccc0ac848d7de2c5456" id="r_gada6cf1edaccccccc0ac848d7de2c5456"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gada6cf1edaccccccc0ac848d7de2c5456"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_ForwardIterator</a>, <a class="el" href="a09261.html">_ForwardIterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gada6cf1edaccccccc0ac848d7de2c5456">std::minmax_element</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gada6cf1edaccccccc0ac848d7de2c5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cce728835fcad7eed2570eb759131d8" id="r_ga7cce728835fcad7eed2570eb759131d8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </td></tr>
<tr class="memitem:ga7cce728835fcad7eed2570eb759131d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga7cce728835fcad7eed2570eb759131d8">std::next_permutation</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last)</td></tr>
<tr class="separator:ga7cce728835fcad7eed2570eb759131d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820" id="r_ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820">std::next_permutation</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d11e737b96371885931c3ba8e3645e" id="r_gad2d11e737b96371885931c3ba8e3645e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:gad2d11e737b96371885931c3ba8e3645e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gad2d11e737b96371885931c3ba8e3645e">std::nth_element</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__nth</a>, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last)</td></tr>
<tr class="separator:gad2d11e737b96371885931c3ba8e3645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b77881d58e25fdfd0536dc100bfe635" id="r_ga0b77881d58e25fdfd0536dc100bfe635"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga0b77881d58e25fdfd0536dc100bfe635"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga0b77881d58e25fdfd0536dc100bfe635">std::nth_element</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__nth</a>, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga0b77881d58e25fdfd0536dc100bfe635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268b5bc10a3f5dac87c6e6e547e70f88" id="r_ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga268b5bc10a3f5dac87c6e6e547e70f88">std::partial_sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __middle, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last)</td></tr>
<tr class="separator:ga268b5bc10a3f5dac87c6e6e547e70f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0a8c56ac512c78bbf5ccee6de8539b" id="r_gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gaca0a8c56ac512c78bbf5ccee6de8539b">std::partial_sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __middle, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gaca0a8c56ac512c78bbf5ccee6de8539b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071176a89f62f2c99841332f9fd9aa0f" id="r_ga071176a89f62f2c99841332f9fd9aa0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:ga071176a89f62f2c99841332f9fd9aa0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga071176a89f62f2c99841332f9fd9aa0f">std::partial_sort_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__result_first</a>, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__result_last</a>)</td></tr>
<tr class="separator:ga071176a89f62f2c99841332f9fd9aa0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97179dae819b2c8f96367a14d3607bc4" id="r_ga97179dae819b2c8f96367a14d3607bc4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga97179dae819b2c8f96367a14d3607bc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga97179dae819b2c8f96367a14d3607bc4">std::partial_sort_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__result_first</a>, <a class="el" href="a09261.html">_RandomAccessIterator</a> <a class="el" href="a09261.html">__result_last</a>, _Compare __comp)</td></tr>
<tr class="separator:ga97179dae819b2c8f96367a14d3607bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8521ac56216e486d761d239b2d59085e" id="r_ga8521ac56216e486d761d239b2d59085e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </td></tr>
<tr class="memitem:ga8521ac56216e486d761d239b2d59085e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga8521ac56216e486d761d239b2d59085e">std::prev_permutation</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last)</td></tr>
<tr class="separator:ga8521ac56216e486d761d239b2d59085e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1304617e63648825d90a5e186d41fbe" id="r_gaf1304617e63648825d90a5e186d41fbe"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gaf1304617e63648825d90a5e186d41fbe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gaf1304617e63648825d90a5e186d41fbe">std::prev_permutation</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gaf1304617e63648825d90a5e186d41fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56b01b6148c1610ce928e662a5e97f0f" id="r_ga56b01b6148c1610ce928e662a5e97f0f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:ga56b01b6148c1610ce928e662a5e97f0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga56b01b6148c1610ce928e662a5e97f0f">std::sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last)</td></tr>
<tr class="separator:ga56b01b6148c1610ce928e662a5e97f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82f396bc6a1d4a9209e2aade9a57a39" id="r_gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#gaf82f396bc6a1d4a9209e2aade9a57a39">std::sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:gaf82f396bc6a1d4a9209e2aade9a57a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8bb8e52b7b0e80301dcbec17225b4a" id="r_ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga7d8bb8e52b7b0e80301dcbec17225b4a">std::stable_sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last)</td></tr>
<tr class="separator:ga7d8bb8e52b7b0e80301dcbec17225b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a3ce3aa8ac2297f8290939a7988596d" id="r_ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </td></tr>
<tr class="memitem:ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01600.html#ga3a3ce3aa8ac2297f8290939a7988596d">std::stable_sort</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, _Compare __comp)</td></tr>
<tr class="separator:ga3a3ce3aa8ac2297f8290939a7988596d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga927cfd3e8df8c15df3fcec6c2af59a82" name="ga927cfd3e8df8c15df3fcec6c2af59a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga927cfd3e8df8c15df3fcec6c2af59a82">&#9670;&#160;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::clamp </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value clamped between lo and hi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>A value of arbitrary type. </td></tr>
    <tr><td class="paramname">__lo</td><td>A lower limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__hi</td><td>An upper limit of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">`__lo`</td><td>if <code>__val &lt; __lo</code> </td></tr>
    <tr><td class="paramname">`__hi`</td><td>if <code>__hi &lt; __val</code> </td></tr>
    <tr><td class="paramname">`__val`</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>_Tp</code> is LessThanComparable and <code>(__hi &lt; __lo)</code> is false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03667">3667</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00731_source.html#l00257">std::max()</a>, and <a class="el" href="a00731_source.html#l00233">std::min()</a>.</p>

</div>
</div>
<a id="ga00e7d39a4bbac23967d87e1dbd763e1e" name="ga00e7d39a4bbac23967d87e1dbd763e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e7d39a4bbac23967d87e1dbd763e1e">&#9670;&#160;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::clamp </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value clamped between lo and hi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__val</td><td>A value of arbitrary type. </td></tr>
    <tr><td class="paramname">__lo</td><td>A lower limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__hi</td><td>An upper limit of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">`__lo`</td><td>if <code>__comp(__val, __lo)</code> </td></tr>
    <tr><td class="paramname">`__hi`</td><td>if <code>__comp(__hi, __val)</code> </td></tr>
    <tr><td class="paramname">`__val`</td><td>otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>__comp(__hi, __lo)</code> is false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03687">3687</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00731_source.html#l00257">std::max()</a>, and <a class="el" href="a00731_source.html#l00233">std::min()</a>.</p>

</div>
</div>
<a id="ga5e5479e1ac5e92b0c1f77bcf762d07e9" name="ga5e5479e1ac5e92b0c1f77bcf762d07e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e5479e1ac5e92b0c1f77bcf762d07e9">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last). </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l02584">2584</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf6a8379ab8a648fd05d52ed0632081fa" name="gaf6a8379ab8a648fd05d52ed0632081fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6a8379ab8a648fd05d52ed0632081fa">&#9670;&#160;</a></span>inplace_merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l02625">2625</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga3a18da5fbc7d6f2b56f43156e13d02d2" name="ga3a18da5fbc7d6f2b56f43156e13d02d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a18da5fbc7d6f2b56f43156e13d02d2">&#9670;&#160;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of a sequence are sorted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03233">3233</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae2dd5c04be65e5bf5419776aeac1eda2" name="gae2dd5c04be65e5bf5419776aeac1eda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2dd5c04be65e5bf5419776aeac1eda2">&#9670;&#160;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the elements of a sequence are sorted according to a comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03248">3248</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1373b346c799069f5c45c05993aeaf7f" name="ga1373b346c799069f5c45c05993aeaf7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1373b346c799069f5c45c05993aeaf7f">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the end of a sorted sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03279">3279</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1e8cc41416bcbf277d408aa81bf1f051" name="ga1e8cc41416bcbf277d408aa81bf1f051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8cc41416bcbf277d408aa81bf1f051">&#9670;&#160;</a></span>is_sorted_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the end of a sorted sequence using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03304">3304</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga8eff9effc89d8fd28bce9a6951b81f5d" name="ga8eff9effc89d8fd28bce9a6951b81f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8eff9effc89d8fd28bce9a6951b81f5d">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_II1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II2</a>&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p><em>Returns true if the sequence of elements defined by the range [first1,last1) is lexicographically less than the sequence of elements defined by the range [first2,last2). Returns false otherwise.</em> (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to <code>memcmp</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l01733">1733</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga9cd54bcbe68e78e8751c700263ae6ef5" name="ga9cd54bcbe68e78e8751c700263ae6ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd54bcbe68e78e8751c700263ae6ef5">&#9670;&#160;</a></span>lexicographical_compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II2</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_II1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II2</a>&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01616.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean true or false.</dd></dl>
<p>The same as the four-parameter <code>lexicographical_compare</code>, but uses the comp parameter instead of <code>&lt;</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l01768">1768</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gab98f0838f871a26317aaa71211b65a9c" name="gab98f0838f871a26317aaa71211b65a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab98f0838f871a26317aaa71211b65a9c">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00257">257</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00989_source.html#l00332">__gnu_parallel::__parallel_nth_element()</a>, <a class="el" href="a00698_source.html#l00639">std::_Deque_base&lt; _Tp, _Alloc &gt;::_M_initialize_map()</a>, <a class="el" href="a00725_source.html#l00932">std::deque&lt; _Tp, _Alloc &gt;::_M_reallocate_map()</a>, <a class="el" href="a00464_source.html#l03667">std::clamp()</a>, <a class="el" href="a00464_source.html#l03687">std::clamp()</a>, <a class="el" href="a01049_source.html#l00122">__gnu_parallel::multiseq_partition()</a>, <a class="el" href="a01049_source.html#l00388">__gnu_parallel::multiseq_selection()</a>, <a class="el" href="a19717_source.html#l00844">std::shuffle_order_engine&lt; _RandomNumberEngine, __k &gt;::operator()()</a>, and <a class="el" href="a00500_source.html#l00080">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>.</p>

</div>
</div>
<a id="gacd491cbbfc0452492f8fe4b7c3760b0d" name="gacd491cbbfc0452492f8fe4b7c3760b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd491cbbfc0452492f8fe4b7c3760b0d">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::max </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01616.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The greater of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00303">303</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gacf8e17bbc480ed6676ec0d1a326f4a05" name="gacf8e17bbc480ed6676ec0d1a326f4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf8e17bbc480ed6676ec0d1a326f4a05">&#9670;&#160;</a></span>max_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum element in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05730">5730</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga672a1736a849c3f4675f4c13a3068884" name="ga672a1736a849c3f4675f4c13a3068884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga672a1736a849c3f4675f4c13a3068884">&#9670;&#160;</a></span>max_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::max_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum element in a range using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the largest value according to __comp. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05755">5755</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga0d39bebd559751b145e409dd2e41ab1d" name="ga0d39bebd559751b145e409dd2e41ab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d39bebd559751b145e409dd2e41ab1d">&#9670;&#160;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator2</a>&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04946">4946</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7d075968551b0f77f71052e8832a5b88" name="ga7d075968551b0f77f71052e8832a5b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d075968551b0f77f71052e8832a5b88">&#9670;&#160;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator2</a>&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result</code> + (__last1 - __first1)<ul>
<li>(__last2 - __first2).</li>
</ul>
</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04997">4997</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae9cf068dc91c8779040669efa4a8cf65" name="gae9cf068dc91c8779040669efa4a8cf65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9cf068dc91c8779040669efa4a8cf65">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00233">233</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a01064_source.html#l00265">__gnu_parallel::__parallel_random_shuffle_drs()</a>, <a class="el" href="a00986_source.html#l00051">__gnu_parallel::__parallel_sort_qs_divide()</a>, <a class="el" href="a00464_source.html#l05845">std::__sample()</a>, <a class="el" href="a01031_source.html#l00081">__gnu_parallel::__search_template()</a>, <a class="el" href="a01064_source.html#l00410">__gnu_parallel::__sequential_random_shuffle()</a>, <a class="el" href="a00464_source.html#l03667">std::clamp()</a>, <a class="el" href="a00464_source.html#l03687">std::clamp()</a>, <a class="el" href="a01169_source.html#l02077">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a01187_source.html#l00498">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02930">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02791">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02771">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a01187_source.html#l00462">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02864">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02964">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a01187_source.html#l00514">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00431_source.html#l03002">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a01187_source.html#l00531">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a01187_source.html#l00479">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00431_source.html#l02900">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a19717_source.html#l03346">std::generate_canonical()</a>, <a class="el" href="a01049_source.html#l00122">__gnu_parallel::multiseq_partition()</a>, <a class="el" href="a01049_source.html#l00388">__gnu_parallel::multiseq_selection()</a>, <a class="el" href="a19717_source.html#l00844">std::shuffle_order_engine&lt; _RandomNumberEngine, __k &gt;::operator()()</a>, <a class="el" href="a00500_source.html#l00080">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>, <a class="el" href="a00650_source.html#l00731">std::basic_istream&lt; _CharT, _Traits &gt;::readsome()</a>, <a class="el" href="a01187_source.html#l00315">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::rfind()</a>, <a class="el" href="a00566_source.html#l00675">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::rfind()</a>, <a class="el" href="a00497_source.html#l00889">std::basic_filebuf&lt; _CharT, encoding_char_traits&lt; _CharT &gt; &gt;::seekpos()</a>, <a class="el" href="a00563_source.html#l00046">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsgetn()</a>, and <a class="el" href="a00563_source.html#l00080">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsputn()</a>.</p>

</div>
</div>
<a id="ga7909b7a198cc9c418432b4b2b138cac1" name="ga7909b7a198cc9c418432b4b2b138cac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7909b7a198cc9c418432b4b2b138cac1">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const _Tp &amp; std::min </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01616.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lesser of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00281">281</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga1bc18030e0f9d1b83be2e8f0718fe72c" name="ga1bc18030e0f9d1b83be2e8f0718fe72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc18030e0f9d1b83be2e8f0718fe72c">&#9670;&#160;</a></span>min_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum element in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05666">5666</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga0c580be620f774d1b197c9db950b42ce" name="ga0c580be620f774d1b197c9db950b42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c580be620f774d1b197c9db950b42ce">&#9670;&#160;</a></span>min_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::min_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum element in a range using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator referencing the first instance of the smallest value according to __comp. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05691">5691</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae02c72c1390894648ba6d61ab8990db6" name="gae02c72c1390894648ba6d61ab8990db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02c72c1390894648ba6d61ab8990db6">&#9670;&#160;</a></span>minmax() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08457.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt; std::minmax </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a,
__b) otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03330">3330</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gad98dfb06baec2f6d60027e169853a05d" name="gad98dfb06baec2f6d60027e169853a05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98dfb06baec2f6d60027e169853a05d">&#9670;&#160;</a></span>minmax() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08457.html">pair</a>&lt; const _Tp &amp;, const _Tp &amp; &gt; std::minmax </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01616.html">comparison functor </a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a,
__b) otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03351">3351</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga857a1caf7ea9852c57b953b919eb1216" name="ga857a1caf7ea9852c57b953b919eb1216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857a1caf7ea9852c57b953b919eb1216">&#9670;&#160;</a></span>minmax_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_ForwardIterator</a>, <a class="el" href="a09261.html">_ForwardIterator</a> &gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03431">3431</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gada6cf1edaccccccc0ac848d7de2c5456" name="gada6cf1edaccccccc0ac848d7de2c5456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6cf1edaccccccc0ac848d7de2c5456">&#9670;&#160;</a></span>minmax_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_ForwardIterator</a>, <a class="el" href="a09261.html">_ForwardIterator</a> &gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03459">3459</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7cce728835fcad7eed2570eb759131d8" name="ga7cce728835fcad7eed2570eb759131d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cce728835fcad7eed2570eb759131d8">&#9670;&#160;</a></span>next_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l02981">2981</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820" name="ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1bd3ed6c1fbd4ba5f8b24fc7caf820">&#9670;&#160;</a></span>next_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03014">3014</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gad2d11e737b96371885931c3ba8e3645e" name="gad2d11e737b96371885931c3ba8e3645e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d11e737b96371885931c3ba8e3645e">&#9670;&#160;</a></span>nth_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a sequence just enough to find a particular position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code>[__first, __last)</code> so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <code>i</code> in the range <code>[__first, __nth)</code> and any iterator <code>j</code> in the range <code>[__nth, __last)</code> it holds that <code>*j &lt; *i</code> is false. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04773">4773</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00731_source.html#l01515">std::__lg()</a>.</p>

</div>
</div>
<a id="ga0b77881d58e25fdfd0536dc100bfe635" name="ga0b77881d58e25fdfd0536dc100bfe635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b77881d58e25fdfd0536dc100bfe635">&#9670;&#160;</a></span>nth_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::nth_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort a sequence just enough to find a particular position using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code>[__first, __last)</code> so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <code>i</code> in the range <code>[__first, __nth)</code> and any iterator <code>j</code> in the range <code>[__nth, __last)</code> it holds that <code>__comp(*j, *i)</code> is false. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04813">4813</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00731_source.html#l01515">std::__lg()</a>.</p>

</div>
</div>
<a id="ga268b5bc10a3f5dac87c6e6e547e70f88" name="ga268b5bc10a3f5dac87c6e6e547e70f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268b5bc10a3f5dac87c6e6e547e70f88">&#9670;&#160;</a></span>partial_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the smallest elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code>(__middle - __first)</code> elements in the range <code>[first, last)</code> and moves them to the range <code>[__first, __middle)</code>. The order of the remaining elements in the range <code>[__middle, __last)</code> is unspecified. After the sort if <code>i</code> and <code>j</code> are iterators in the range <code>[__first, __middle)</code> such that <code>i</code> precedes <code>j</code> and <code>k</code> is an iterator in the range <code>[__middle, __last)</code> then <code>*j &lt; *i</code> and <code>*k &lt; *i</code> are both false. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04697">4697</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaca0a8c56ac512c78bbf5ccee6de8539b" name="gaca0a8c56ac512c78bbf5ccee6de8539b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0a8c56ac512c78bbf5ccee6de8539b">&#9670;&#160;</a></span>partial_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::partial_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code>(__middle - __first)</code> elements in the range <code>[__first, __last)</code> and moves them to the range <code>[__first, __middle)</code>. The order of the remaining elements in the range <code>[__middle, __last)</code> is unspecified. After the sort if <code>i</code> and <code>j</code> are iterators in the range <code>[__first, __middle)</code> such that <code>i</code> precedes <code>j</code> and <code>k</code> is an iterator in the range <code>[__middle, __last)</code> then <code>*__comp(j, *i)</code> and <code>__comp(*k, *i)</code> are both false. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04736">4736</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga071176a89f62f2c99841332f9fd9aa0f" name="ga071176a89f62f2c99841332f9fd9aa0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071176a89f62f2c99841332f9fd9aa0f">&#9670;&#160;</a></span>partial_sort_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_RandomAccessIterator</a> std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__result_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the smallest elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest <code>N</code> values from the range <code>[__first, __last)</code> to the range beginning at <code>__result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code>(__last - __first)</code> and <code>(__result_last - __result_first)</code>. After the sort if <code>i</code> and <code>j</code> are iterators in the range <code>[__result_first,__result_first + N)</code> such that <code>i</code> precedes <code>j</code> then <code>*j &lt; *i</code> is false. The value returned is <code>__result_first + N</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01704">1704</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga97179dae819b2c8f96367a14d3607bc4" name="ga97179dae819b2c8f96367a14d3607bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97179dae819b2c8f96367a14d3607bc4">&#9670;&#160;</a></span>partial_sort_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_RandomAccessIterator</a> std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__result_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest <code>N</code> values from the range <code>[__first, __last)</code> to the range beginning at <code>result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code>(__last - __first)</code> and <code>(__result_last - __result_first)</code>. After the sort if <code>i</code> and <code>j</code> are iterators in the range <code>[__result_first, __result_first + N)</code> such that <code>i</code> precedes <code>j</code> then <code>__comp(*j, *i)</code> is false. The value returned is <code>__result_first + N</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01755">1755</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga8521ac56216e486d761d239b2d59085e" name="ga8521ac56216e486d761d239b2d59085e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8521ac56216e486d761d239b2d59085e">&#9670;&#160;</a></span>prev_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03084">3084</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf1304617e63648825d90a5e186d41fbe" name="gaf1304617e63648825d90a5e186d41fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1304617e63648825d90a5e186d41fbe">&#9670;&#160;</a></span>prev_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03117">3117</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga56b01b6148c1610ce928e662a5e97f0f" name="ga56b01b6148c1610ce928e662a5e97f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56b01b6148c1610ce928e662a5e97f0f">&#9670;&#160;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code>[__first, __last)</code> in ascending order, such that for each iterator <code>i</code> in the range <code>[__first, __last - 1)</code>, <code>*(i+1) &lt; *i</code> is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04851">4851</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf82f396bc6a1d4a9209e2aade9a57a39" name="gaf82f396bc6a1d4a9209e2aade9a57a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf82f396bc6a1d4a9209e2aade9a57a39">&#9670;&#160;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code>[__first, __last)</code> in ascending order, such that <code>__comp(*(i+1), *i)</code> is false for every iterator <code>i</code> in the range <code>[__first, __last - 1)</code>.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04882">4882</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7d8bb8e52b7b0e80301dcbec17225b4a" name="ga7d8bb8e52b7b0e80301dcbec17225b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d8bb8e52b7b0e80301dcbec17225b4a">&#9670;&#160;</a></span>stable_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>x&lt;y</code> is false and <code>y&lt;x</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05073">5073</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga3a3ce3aa8ac2297f8290939a7988596d" name="ga3a3ce3aa8ac2297f8290939a7988596d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a3ce3aa8ac2297f8290939a7988596d">&#9670;&#160;</a></span>stable_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> _Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::stable_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__comp(x,y)</code> is false and <code>__comp(y,x)</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l05107">5107</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>

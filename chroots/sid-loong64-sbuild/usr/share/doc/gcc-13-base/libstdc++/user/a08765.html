<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a08765.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a08762.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01569.html">Containers</a> &raquo; <a class="el" href="a01572.html">Unordered Associative</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00227_source.html">unordered_map</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae2c81650686b3dda757789b242919626" id="r_ae2c81650686b3dda757789b242919626"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ae2c81650686b3dda757789b242919626">node_type</a> = <a class="el" href="a09261.html">typename</a> _Hashtable::node_type</td></tr>
<tr class="separator:ae2c81650686b3dda757789b242919626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae371392b325c1cdecb9bfdb891ee9fb0" id="r_ae371392b325c1cdecb9bfdb891ee9fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a></td></tr>
<tr class="separator:ae371392b325c1cdecb9bfdb891ee9fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4baa45433c393ecfab2c784b8de381e8" id="r_a4baa45433c393ecfab2c784b8de381e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a></td></tr>
<tr class="separator:a4baa45433c393ecfab2c784b8de381e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1544ab885cd443cf557eb35db830e8" id="r_a3e1544ab885cd443cf557eb35db830e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::mapped_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a3e1544ab885cd443cf557eb35db830e8">mapped_type</a></td></tr>
<tr class="separator:a3e1544ab885cd443cf557eb35db830e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a087ced0dd9a5d8e57c101627b67fb6" id="r_a8a087ced0dd9a5d8e57c101627b67fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a></td></tr>
<tr class="separator:a8a087ced0dd9a5d8e57c101627b67fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabc6af09a31459a08760bcec32a0b6d" id="r_afabc6af09a31459a08760bcec32a0b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a></td></tr>
<tr class="separator:afabc6af09a31459a08760bcec32a0b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5213cbfd6797faef226b949240b8ec" id="r_aab5213cbfd6797faef226b949240b8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a></td></tr>
<tr class="separator:aab5213cbfd6797faef226b949240b8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa9c05aec6bb3f18770d191869543334a" id="r_aa9c05aec6bb3f18770d191869543334a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aa9c05aec6bb3f18770d191869543334a">pointer</a></td></tr>
<tr class="separator:aa9c05aec6bb3f18770d191869543334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aca480ec930cab8cee31638ec6aa0c" id="r_ac2aca480ec930cab8cee31638ec6aa0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ac2aca480ec930cab8cee31638ec6aa0c">const_pointer</a></td></tr>
<tr class="separator:ac2aca480ec930cab8cee31638ec6aa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08487e5381fd61795c61cfa0fed8e48f" id="r_a08487e5381fd61795c61cfa0fed8e48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a08487e5381fd61795c61cfa0fed8e48f">reference</a></td></tr>
<tr class="separator:a08487e5381fd61795c61cfa0fed8e48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580c722f453604f50c163788a75fd6c3" id="r_a580c722f453604f50c163788a75fd6c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a580c722f453604f50c163788a75fd6c3">const_reference</a></td></tr>
<tr class="separator:a580c722f453604f50c163788a75fd6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fffce26090303390cc7fce06b5f6615" id="r_a0fffce26090303390cc7fce06b5f6615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a></td></tr>
<tr class="separator:a0fffce26090303390cc7fce06b5f6615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98a77485a1a68eaadb6a7c8b5d4b141" id="r_ac98a77485a1a68eaadb6a7c8b5d4b141"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a></td></tr>
<tr class="separator:ac98a77485a1a68eaadb6a7c8b5d4b141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb5d0ca110f847b3fceed2d07472710" id="r_a8cb5d0ca110f847b3fceed2d07472710"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a8cb5d0ca110f847b3fceed2d07472710">local_iterator</a></td></tr>
<tr class="separator:a8cb5d0ca110f847b3fceed2d07472710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04f4d4643b5de9638d2f5aaa31d94e5" id="r_ab04f4d4643b5de9638d2f5aaa31d94e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a></td></tr>
<tr class="separator:ab04f4d4643b5de9638d2f5aaa31d94e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e187c541bf3fe290dd21b514abd024" id="r_ab9e187c541bf3fe290dd21b514abd024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a></td></tr>
<tr class="separator:ab9e187c541bf3fe290dd21b514abd024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91e542e87512944adfb13fcff51d7c8" id="r_ab91e542e87512944adfb13fcff51d7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ab91e542e87512944adfb13fcff51d7c8">difference_type</a></td></tr>
<tr class="separator:ab91e542e87512944adfb13fcff51d7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a722b99e1c15c3f0538bb6e2a2df15c32" id="r_a722b99e1c15c3f0538bb6e2a2df15c32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a722b99e1c15c3f0538bb6e2a2df15c32">unordered_multimap</a> ()=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:a722b99e1c15c3f0538bb6e2a2df15c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad1e3e0bcd96580607c8dbbe9853341" id="r_a0ad1e3e0bcd96580607c8dbbe9853341"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:a0ad1e3e0bcd96580607c8dbbe9853341"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a0ad1e3e0bcd96580607c8dbbe9853341">unordered_multimap</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a0ad1e3e0bcd96580607c8dbbe9853341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8947ad5828084f1eb618f7513f0074f6" id="r_a8947ad5828084f1eb618f7513f0074f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:a8947ad5828084f1eb618f7513f0074f6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a8947ad5828084f1eb618f7513f0074f6">unordered_multimap</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a8947ad5828084f1eb618f7513f0074f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fbf8cd5ee67d47203f4a01bb2d6568" id="r_a94fbf8cd5ee67d47203f4a01bb2d6568"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:a94fbf8cd5ee67d47203f4a01bb2d6568"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a94fbf8cd5ee67d47203f4a01bb2d6568">unordered_multimap</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n=0, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>(), const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>(), const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a=<a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>())</td></tr>
<tr class="separator:a94fbf8cd5ee67d47203f4a01bb2d6568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ecc0576cd505fe517ffbbae066d3d6" id="r_ab7ecc0576cd505fe517ffbbae066d3d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ab7ecc0576cd505fe517ffbbae066d3d6">unordered_multimap</a> (const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:ab7ecc0576cd505fe517ffbbae066d3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d147e18b9233f333c7cd4921fc4aa7" id="r_af3d147e18b9233f333c7cd4921fc4aa7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#af3d147e18b9233f333c7cd4921fc4aa7">unordered_multimap</a> (const <a class="el" href="a08765.html">unordered_multimap</a> &amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:af3d147e18b9233f333c7cd4921fc4aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4788216736d2ae3a9b9452b4548ab3" id="r_a6f4788216736d2ae3a9b9452b4548ab3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a6f4788216736d2ae3a9b9452b4548ab3">unordered_multimap</a> (const <a class="el" href="a08765.html">unordered_multimap</a> &amp;<a class="el" href="a09261.html">__ummap</a>, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a6f4788216736d2ae3a9b9452b4548ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a00ef1d495e73e9ce1ef805e005db97" id="r_a1a00ef1d495e73e9ce1ef805e005db97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a1a00ef1d495e73e9ce1ef805e005db97">unordered_multimap</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a1a00ef1d495e73e9ce1ef805e005db97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d4c0a0d0bff8a138a8aba24ed49955" id="r_a03d4c0a0d0bff8a138a8aba24ed49955"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a03d4c0a0d0bff8a138a8aba24ed49955">unordered_multimap</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a03d4c0a0d0bff8a138a8aba24ed49955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11b69676f9f379ea2274cd722fae38d" id="r_aa11b69676f9f379ea2274cd722fae38d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aa11b69676f9f379ea2274cd722fae38d">unordered_multimap</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n=0, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>(), const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>(), const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a=<a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>())</td></tr>
<tr class="separator:aa11b69676f9f379ea2274cd722fae38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f0e220345bda3d301875be9dfe7ea2" id="r_a00f0e220345bda3d301875be9dfe7ea2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a00f0e220345bda3d301875be9dfe7ea2">unordered_multimap</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a00f0e220345bda3d301875be9dfe7ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7a7cfad4ac8c46618a5fe65c641bf7" id="r_a6c7a7cfad4ac8c46618a5fe65c641bf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a6c7a7cfad4ac8c46618a5fe65c641bf7">unordered_multimap</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a6c7a7cfad4ac8c46618a5fe65c641bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afc31e2217e4e10c6c821d38d9fa668" id="r_a4afc31e2217e4e10c6c821d38d9fa668"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4afc31e2217e4e10c6c821d38d9fa668">unordered_multimap</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n, const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>(), const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>(), const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a=<a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>())</td></tr>
<tr class="separator:a4afc31e2217e4e10c6c821d38d9fa668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70b33e6e61485413fcb3bd22ac6d4ee" id="r_ab70b33e6e61485413fcb3bd22ac6d4ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ab70b33e6e61485413fcb3bd22ac6d4ee">unordered_multimap</a> (<a class="el" href="a08765.html">unordered_multimap</a> &amp;&amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:ab70b33e6e61485413fcb3bd22ac6d4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4120fbcae709a132d7fb242884eba762" id="r_a4120fbcae709a132d7fb242884eba762"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4120fbcae709a132d7fb242884eba762">unordered_multimap</a> (<a class="el" href="a08765.html">unordered_multimap</a> &amp;&amp;<a class="el" href="a09261.html">__ummap</a>, const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;__a) noexcept(noexcept(<a class="el" href="a09261.html">_Hashtable</a>(<a class="el" href="a01595.html#ga7b69ea61cf06291d5c8b44e64cf6c280">std::move</a>(__ummap._M_h), __a)))</td></tr>
<tr class="separator:a4120fbcae709a132d7fb242884eba762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a71d9534d9f9cf27de31a025a3053" id="r_a1e8a71d9534d9f9cf27de31a025a3053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a1e8a71d9534d9f9cf27de31a025a3053">begin</a> () noexcept</td></tr>
<tr class="separator:a1e8a71d9534d9f9cf27de31a025a3053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72025b859653a260f7e14bac43feae79" id="r_a72025b859653a260f7e14bac43feae79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a8cb5d0ca110f847b3fceed2d07472710">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a72025b859653a260f7e14bac43feae79">begin</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n)</td></tr>
<tr class="separator:a72025b859653a260f7e14bac43feae79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af8e0bde2da18a7c91c256a60e02bf6" id="r_a0af8e0bde2da18a7c91c256a60e02bf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a0af8e0bde2da18a7c91c256a60e02bf6">bucket</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;<a class="el" href="a09261.html">__key</a>) const</td></tr>
<tr class="separator:a0af8e0bde2da18a7c91c256a60e02bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c57013bd56a6fc373659c4e5807a64d" id="r_a0c57013bd56a6fc373659c4e5807a64d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a0c57013bd56a6fc373659c4e5807a64d">bucket_count</a> () const noexcept</td></tr>
<tr class="separator:a0c57013bd56a6fc373659c4e5807a64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac669fa17538b9e96dd43a9ed59de8ba0" id="r_ac669fa17538b9e96dd43a9ed59de8ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ac669fa17538b9e96dd43a9ed59de8ba0">bucket_size</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n) const</td></tr>
<tr class="separator:ac669fa17538b9e96dd43a9ed59de8ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96159c845937ab5729b5ed41a7ef6071" id="r_a96159c845937ab5729b5ed41a7ef6071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a96159c845937ab5729b5ed41a7ef6071">clear</a> () noexcept</td></tr>
<tr class="separator:a96159c845937ab5729b5ed41a7ef6071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d00357a4ca15a9cdffa4aef992859c8" id="r_a4d00357a4ca15a9cdffa4aef992859c8"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a4d00357a4ca15a9cdffa4aef992859c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a4d00357a4ca15a9cdffa4aef992859c8">emplace</a> (<a class="el" href="a09261.html">_Args</a> &amp;&amp;... <a class="el" href="a09261.html">__args</a>)</td></tr>
<tr class="separator:a4d00357a4ca15a9cdffa4aef992859c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f415a309a77497c41538b60d358fed" id="r_af7f415a309a77497c41538b60d358fed"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:af7f415a309a77497c41538b60d358fed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#af7f415a309a77497c41538b60d358fed">emplace_hint</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__pos</a>, <a class="el" href="a09261.html">_Args</a> &amp;&amp;... <a class="el" href="a09261.html">__args</a>)</td></tr>
<tr class="separator:af7f415a309a77497c41538b60d358fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14f82918a4a9fcfaf3c4ce218d1e70" id="r_ada14f82918a4a9fcfaf3c4ce218d1e70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ada14f82918a4a9fcfaf3c4ce218d1e70">empty</a> () const noexcept</td></tr>
<tr class="separator:ada14f82918a4a9fcfaf3c4ce218d1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708a8efab9b1b9d8f1e41ca3ae2caaa5" id="r_a708a8efab9b1b9d8f1e41ca3ae2caaa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a708a8efab9b1b9d8f1e41ca3ae2caaa5">end</a> () noexcept</td></tr>
<tr class="separator:a708a8efab9b1b9d8f1e41ca3ae2caaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4209ed9ce2c4549ded624445fa59416f" id="r_a4209ed9ce2c4549ded624445fa59416f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a8cb5d0ca110f847b3fceed2d07472710">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4209ed9ce2c4549ded624445fa59416f">end</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n)</td></tr>
<tr class="separator:a4209ed9ce2c4549ded624445fa59416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09397dfd53f29fdbc8809d37ab11b142" id="r_a09397dfd53f29fdbc8809d37ab11b142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a09397dfd53f29fdbc8809d37ab11b142">erase</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a09397dfd53f29fdbc8809d37ab11b142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e97c00a7b10fb37726206ebc57800" id="r_aa38e97c00a7b10fb37726206ebc57800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aa38e97c00a7b10fb37726206ebc57800">erase</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> __first, <a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> __last)</td></tr>
<tr class="separator:aa38e97c00a7b10fb37726206ebc57800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d61c0eb6737c76b2e77c9ab37ef2acd" id="r_a4d61c0eb6737c76b2e77c9ab37ef2acd"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4d61c0eb6737c76b2e77c9ab37ef2acd">extract</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;<a class="el" href="a09261.html">__key</a>)</td></tr>
<tr class="separator:a4d61c0eb6737c76b2e77c9ab37ef2acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea03e4d3fc99980d93c352d9be43dca6" id="r_aea03e4d3fc99980d93c352d9be43dca6"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aea03e4d3fc99980d93c352d9be43dca6">extract</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__pos</a>)</td></tr>
<tr class="separator:aea03e4d3fc99980d93c352d9be43dca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb20a72b3b3284f980ec948c79e3b59d" id="r_afb20a72b3b3284f980ec948c79e3b59d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#afb20a72b3b3284f980ec948c79e3b59d">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:afb20a72b3b3284f980ec948c79e3b59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208a268d709e23f97d5763d2f24de4f2" id="r_a208a268d709e23f97d5763d2f24de4f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a208a268d709e23f97d5763d2f24de4f2">hash_function</a> () const</td></tr>
<tr class="separator:a208a268d709e23f97d5763d2f24de4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f035c31a44c4051965af7868d40e77" id="r_a46f035c31a44c4051965af7868d40e77"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:a46f035c31a44c4051965af7868d40e77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a46f035c31a44c4051965af7868d40e77">insert</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last)</td></tr>
<tr class="separator:a46f035c31a44c4051965af7868d40e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212cc153aa0e4404d73ff85711aa98b5" id="r_a212cc153aa0e4404d73ff85711aa98b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a212cc153aa0e4404d73ff85711aa98b5">insert</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, node_type &amp;&amp;<a class="el" href="a09261.html">__nh</a>)</td></tr>
<tr class="separator:a212cc153aa0e4404d73ff85711aa98b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1935806673ced5dae48aa64d8cabc3" id="r_acb1935806673ced5dae48aa64d8cabc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#acb1935806673ced5dae48aa64d8cabc3">insert</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>)</td></tr>
<tr class="separator:acb1935806673ced5dae48aa64d8cabc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1a926a6d12e51f5ab00abeb26e83cf" id="r_a5b1a926a6d12e51f5ab00abeb26e83cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a5b1a926a6d12e51f5ab00abeb26e83cf">insert</a> (node_type &amp;&amp;<a class="el" href="a09261.html">__nh</a>)</td></tr>
<tr class="separator:a5b1a926a6d12e51f5ab00abeb26e83cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32226343bc7c4b8b0b14914fd3d105cb" id="r_a32226343bc7c4b8b0b14914fd3d105cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a32226343bc7c4b8b0b14914fd3d105cb">key_eq</a> () const</td></tr>
<tr class="separator:a32226343bc7c4b8b0b14914fd3d105cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02888ba9dce21c5e16ba09734ebdb642" id="r_a02888ba9dce21c5e16ba09734ebdb642"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a02888ba9dce21c5e16ba09734ebdb642">load_factor</a> () const noexcept</td></tr>
<tr class="separator:a02888ba9dce21c5e16ba09734ebdb642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193e48c36ac0f5888911cf991428a287" id="r_a193e48c36ac0f5888911cf991428a287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a193e48c36ac0f5888911cf991428a287">max_bucket_count</a> () const noexcept</td></tr>
<tr class="separator:a193e48c36ac0f5888911cf991428a287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72250fbcb87cc6ea4998eb8f00465650" id="r_a72250fbcb87cc6ea4998eb8f00465650"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a72250fbcb87cc6ea4998eb8f00465650">max_load_factor</a> () const noexcept</td></tr>
<tr class="separator:a72250fbcb87cc6ea4998eb8f00465650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea08a0d2315df4b6da1318c74be7114" id="r_afea08a0d2315df4b6da1318c74be7114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#afea08a0d2315df4b6da1318c74be7114">max_load_factor</a> (float <a class="el" href="a09261.html">__z</a>)</td></tr>
<tr class="separator:afea08a0d2315df4b6da1318c74be7114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd0a24f61c8161dbd0fe216ead19142" id="r_accd0a24f61c8161dbd0fe216ead19142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#accd0a24f61c8161dbd0fe216ead19142">max_size</a> () const noexcept</td></tr>
<tr class="separator:accd0a24f61c8161dbd0fe216ead19142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6031be71a267c406b2e03471565be797" id="r_a6031be71a267c406b2e03471565be797"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:a6031be71a267c406b2e03471565be797"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a6031be71a267c406b2e03471565be797">merge</a> (<a class="el" href="a08769.html">unordered_map</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:a6031be71a267c406b2e03471565be797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad113c08ea4c87c7f3413fd999ac5ff05" id="r_ad113c08ea4c87c7f3413fd999ac5ff05"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:ad113c08ea4c87c7f3413fd999ac5ff05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#ad113c08ea4c87c7f3413fd999ac5ff05">merge</a> (<a class="el" href="a08769.html">unordered_map</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:ad113c08ea4c87c7f3413fd999ac5ff05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdc22e9ef58e2074ee1a9b4375faedc" id="r_a4bdc22e9ef58e2074ee1a9b4375faedc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:a4bdc22e9ef58e2074ee1a9b4375faedc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a4bdc22e9ef58e2074ee1a9b4375faedc">merge</a> (<a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:a4bdc22e9ef58e2074ee1a9b4375faedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aabe74fe7d7e84f2cafa3f8175b1dd5" id="r_a1aabe74fe7d7e84f2cafa3f8175b1dd5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:a1aabe74fe7d7e84f2cafa3f8175b1dd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a1aabe74fe7d7e84f2cafa3f8175b1dd5">merge</a> (<a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:a1aabe74fe7d7e84f2cafa3f8175b1dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308ed5b6c114249a5353787d9ed05969" id="r_a308ed5b6c114249a5353787d9ed05969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html">unordered_multimap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a308ed5b6c114249a5353787d9ed05969">operator=</a> (const <a class="el" href="a08765.html">unordered_multimap</a> &amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:a308ed5b6c114249a5353787d9ed05969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad305e11611aa4ca5f9315de388f4a6" id="r_a4ad305e11611aa4ca5f9315de388f4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html">unordered_multimap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4ad305e11611aa4ca5f9315de388f4a6">operator=</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>)</td></tr>
<tr class="separator:a4ad305e11611aa4ca5f9315de388f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e6f88c35b73121fb317d132e38672d" id="r_a80e6f88c35b73121fb317d132e38672d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html">unordered_multimap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a80e6f88c35b73121fb317d132e38672d">operator=</a> (<a class="el" href="a08765.html">unordered_multimap</a> &amp;&amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:a80e6f88c35b73121fb317d132e38672d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9032d22474fc3c5ec4d0b74362b5f4e" id="r_ac9032d22474fc3c5ec4d0b74362b5f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ac9032d22474fc3c5ec4d0b74362b5f4e">rehash</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n)</td></tr>
<tr class="separator:ac9032d22474fc3c5ec4d0b74362b5f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9167538c4058279e45627d0a68f3d030" id="r_a9167538c4058279e45627d0a68f3d030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a9167538c4058279e45627d0a68f3d030">reserve</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n)</td></tr>
<tr class="separator:a9167538c4058279e45627d0a68f3d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02efb64c18107a5c4f13a1983cfa5a3" id="r_af02efb64c18107a5c4f13a1983cfa5a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#af02efb64c18107a5c4f13a1983cfa5a3">size</a> () const noexcept</td></tr>
<tr class="separator:af02efb64c18107a5c4f13a1983cfa5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d3f27e1315796ddcc9b55378f90ce7" id="r_ac8d3f27e1315796ddcc9b55378f90ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ac8d3f27e1315796ddcc9b55378f90ce7">swap</a> (<a class="el" href="a08765.html">unordered_multimap</a> &amp;__x) noexcept(noexcept(_M_h.swap(__x._M_h)))</td></tr>
<tr class="separator:ac8d3f27e1315796ddcc9b55378f90ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1fd8297776af120bf58bb6252562fc35" id="r_a1fd8297776af120bf58bb6252562fc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a1fd8297776af120bf58bb6252562fc35">begin</a> () const noexcept</td></tr>
<tr class="separator:a1fd8297776af120bf58bb6252562fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c99977950ad720b2b10f6daf6c31ab" id="r_ae1c99977950ad720b2b10f6daf6c31ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ae1c99977950ad720b2b10f6daf6c31ab">cbegin</a> () const noexcept</td></tr>
<tr class="separator:ae1c99977950ad720b2b10f6daf6c31ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0921ff9d001238f2f5b92f025378a37d" id="r_a0921ff9d001238f2f5b92f025378a37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a0921ff9d001238f2f5b92f025378a37d">end</a> () const noexcept</td></tr>
<tr class="separator:a0921ff9d001238f2f5b92f025378a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5c6d3a39a12f7d21e8886534eaa591" id="r_acc5c6d3a39a12f7d21e8886534eaa591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#acc5c6d3a39a12f7d21e8886534eaa591">cend</a> () const noexcept</td></tr>
<tr class="separator:acc5c6d3a39a12f7d21e8886534eaa591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a79303f819716015a95be11962dda3e53" id="r_a79303f819716015a95be11962dda3e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a79303f819716015a95be11962dda3e53">insert</a> (const <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a79303f819716015a95be11962dda3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f5c66280686af351a204b1d98774b6" id="r_a73f5c66280686af351a204b1d98774b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a73f5c66280686af351a204b1d98774b6">insert</a> (<a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a73f5c66280686af351a204b1d98774b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b6ae5420b725091adca9268a43900f" id="r_ac3b6ae5420b725091adca9268a43900f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pair</a> &gt; </td></tr>
<tr class="memitem:ac3b6ae5420b725091adca9268a43900f"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04005.html">is_constructible</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a>, <a class="el" href="a09261.html">_Pair</a> &amp;&amp; &gt;::value, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#ac3b6ae5420b725091adca9268a43900f">insert</a> (<a class="el" href="a09261.html">_Pair</a> &amp;&amp;__x)</td></tr>
<tr class="separator:ac3b6ae5420b725091adca9268a43900f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aeb4625ec1e0a22af00ccb220e4c7c7b2" id="r_aeb4625ec1e0a22af00ccb220e4c7c7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aeb4625ec1e0a22af00ccb220e4c7c7b2">insert</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, const <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;__x)</td></tr>
<tr class="separator:aeb4625ec1e0a22af00ccb220e4c7c7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90dcd39d44bdeffe788e78ca829d639" id="r_af90dcd39d44bdeffe788e78ca829d639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#af90dcd39d44bdeffe788e78ca829d639">insert</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:af90dcd39d44bdeffe788e78ca829d639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246ef63aba02155fc1cf43edfe84cf84" id="r_a246ef63aba02155fc1cf43edfe84cf84"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pair</a> &gt; </td></tr>
<tr class="memitem:a246ef63aba02155fc1cf43edfe84cf84"><td class="memTemplItemLeft" align="right" valign="top">__enable_if_t&lt; <a class="el" href="a04005.html">is_constructible</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a>, <a class="el" href="a09261.html">_Pair</a> &amp;&amp; &gt;::value, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a246ef63aba02155fc1cf43edfe84cf84">insert</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, <a class="el" href="a09261.html">_Pair</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a246ef63aba02155fc1cf43edfe84cf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a671564fa7d5dd0e04b651e78861c89ba" id="r_a671564fa7d5dd0e04b651e78861c89ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a671564fa7d5dd0e04b651e78861c89ba">erase</a> (<a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a09261.html">__position</a>)</td></tr>
<tr class="separator:a671564fa7d5dd0e04b651e78861c89ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eec5ee5f497c48d356443110934fdd" id="r_a08eec5ee5f497c48d356443110934fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a08eec5ee5f497c48d356443110934fdd">erase</a> (<a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a09261.html">__position</a>)</td></tr>
<tr class="separator:a08eec5ee5f497c48d356443110934fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a9f64e8fbc46b2fec76e96499ac91c8b6" id="r_a9f64e8fbc46b2fec76e96499ac91c8b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a9f64e8fbc46b2fec76e96499ac91c8b6">find</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a9f64e8fbc46b2fec76e96499ac91c8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41564272341ae36b4955b6c439115ccc" id="r_a41564272341ae36b4955b6c439115ccc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a41564272341ae36b4955b6c439115ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#a41564272341ae36b4955b6c439115ccc">find</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x))</td></tr>
<tr class="separator:a41564272341ae36b4955b6c439115ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a54562ef76d4966a496b86691fdfb12" id="r_a3a54562ef76d4966a496b86691fdfb12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a3a54562ef76d4966a496b86691fdfb12">find</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a3a54562ef76d4966a496b86691fdfb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddd1f13087ca78351420edf2a149b4" id="r_aaeddd1f13087ca78351420edf2a149b4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:aaeddd1f13087ca78351420edf2a149b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#aaeddd1f13087ca78351420edf2a149b4">find</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x))</td></tr>
<tr class="separator:aaeddd1f13087ca78351420edf2a149b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a323e46db071ea6d46dca69efbbc4d075" id="r_a323e46db071ea6d46dca69efbbc4d075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a323e46db071ea6d46dca69efbbc4d075">count</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a323e46db071ea6d46dca69efbbc4d075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1723fa0dcc14342665b4a370c89065d" id="r_aa1723fa0dcc14342665b4a370c89065d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:aa1723fa0dcc14342665b4a370c89065d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#aa1723fa0dcc14342665b4a370c89065d">count</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_count_tr(__x))</td></tr>
<tr class="separator:aa1723fa0dcc14342665b4a370c89065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4f74897455d878fc8ae828482038513d" id="r_a4f74897455d878fc8ae828482038513d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a4f74897455d878fc8ae828482038513d">contains</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a4f74897455d878fc8ae828482038513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d31de17a110aa64b512196a80270de" id="r_ac5d31de17a110aa64b512196a80270de"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:ac5d31de17a110aa64b512196a80270de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#ac5d31de17a110aa64b512196a80270de">contains</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x), <a class="el" href="a09261.html">void</a>(), <a class="el" href="a09261.html">true</a>)</td></tr>
<tr class="separator:ac5d31de17a110aa64b512196a80270de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0b571a73d2cfd776608b01bede707492" id="r_a0b571a73d2cfd776608b01bede707492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a0b571a73d2cfd776608b01bede707492">equal_range</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a0b571a73d2cfd776608b01bede707492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af994cd522ccb97aae1122cf170f57591" id="r_af994cd522ccb97aae1122cf170f57591"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:af994cd522ccb97aae1122cf170f57591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#af994cd522ccb97aae1122cf170f57591">equal_range</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(__x))</td></tr>
<tr class="separator:af994cd522ccb97aae1122cf170f57591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c0b814290c4c507a7188cd2bb65dc" id="r_a946c0b814290c4c507a7188cd2bb65dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>, <a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#a946c0b814290c4c507a7188cd2bb65dc">equal_range</a> (const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a946c0b814290c4c507a7188cd2bb65dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff76d30a0860ad9acde10b74d794621a" id="r_aff76d30a0860ad9acde10b74d794621a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:aff76d30a0860ad9acde10b74d794621a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#aff76d30a0860ad9acde10b74d794621a">equal_range</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;__x) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(__x))</td></tr>
<tr class="separator:aff76d30a0860ad9acde10b74d794621a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aabce46436201e63f88dbebc168f9d84a" id="r_aabce46436201e63f88dbebc168f9d84a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aabce46436201e63f88dbebc168f9d84a">begin</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n) const</td></tr>
<tr class="separator:aabce46436201e63f88dbebc168f9d84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f2132ee625dc5b3a48d28a495d552f" id="r_ad4f2132ee625dc5b3a48d28a495d552f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#ad4f2132ee625dc5b3a48d28a495d552f">cbegin</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n) const</td></tr>
<tr class="separator:ad4f2132ee625dc5b3a48d28a495d552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa7cd9ddc32c88838cfcd1f2cc53ae5ab" id="r_aa7cd9ddc32c88838cfcd1f2cc53ae5ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aa7cd9ddc32c88838cfcd1f2cc53ae5ab">end</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n) const</td></tr>
<tr class="separator:aa7cd9ddc32c88838cfcd1f2cc53ae5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabc377e8c2f5b367388ee5e4e0aff99" id="r_aeabc377e8c2f5b367388ee5e4e0aff99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08765.html#aeabc377e8c2f5b367388ee5e4e0aff99">cend</a> (<a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> __n) const</td></tr>
<tr class="separator:aeabc377e8c2f5b367388ee5e4e0aff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aba8867c198f79894afce77f081cb0ab3" id="r_aba8867c198f79894afce77f081cb0ab3"><td class="memTemplParams" colspan="2"><a id="aba8867c198f79894afce77f081cb0ab3" name="aba8867c198f79894afce77f081cb0ab3"></a>
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Tp1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred1</a> , <a class="el" href="a09261.html">typename</a> _Alloc1 &gt; </td></tr>
<tr class="memitem:aba8867c198f79894afce77f081cb0ab3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key1</a>, <a class="el" href="a09261.html">_Tp1</a>, <a class="el" href="a09261.html">_Hash1</a>, <a class="el" href="a09261.html">_Pred1</a>, _Alloc1 &gt; &amp;, const <a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key1</a>, <a class="el" href="a09261.html">_Tp1</a>, <a class="el" href="a09261.html">_Hash1</a>, <a class="el" href="a09261.html">_Pred1</a>, _Alloc1 &gt; &amp;)</td></tr>
<tr class="separator:aba8867c198f79894afce77f081cb0ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d" id="r_af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> &gt; </td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">class</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08765.html#af0ba6094bfef194c2c3895c5ea1efa6d">std::_Hash_merge_helper</a></td></tr>
<tr class="separator:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a>, <a class="el" href="a09261.html">typename</a> _Tp, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a> = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a> = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt;<br />
class std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;</div><p>A standard container composed of equivalent keys (possibly containing multiple of each key value) that associates values of another type with the keys. </p>
<dl class="section since"><dt>Since</dt><dd>C++11</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Key</td><td>Type of key objects. </td></tr>
    <tr><td class="paramname">_Tp</td><td>Type of mapped objects. </td></tr>
    <tr><td class="paramname">_Hash</td><td>Hashing function object type, defaults to hash&lt;_Value&gt;. </td></tr>
    <tr><td class="paramname">_Pred</td><td>Predicate function object type, defaults to equal_to&lt;_Value&gt;. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to std::allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, and <a href="tables.html#xx">unordered associative container</a></p>
<p>The resulting value type of the container is std::pair&lt;const _Key, _Tp&gt;.</p>
<p>Base is _Hashtable, dispatched at compile time via template alias __ummap_hashtable. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01254">1254</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aab5213cbfd6797faef226b949240b8ec" name="aab5213cbfd6797faef226b949240b8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5213cbfd6797faef226b949240b8ec">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::allocator_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01268">1268</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac98a77485a1a68eaadb6a7c8b5d4b141" name="ac98a77485a1a68eaadb6a7c8b5d4b141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98a77485a1a68eaadb6a7c8b5d4b141">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_iterator <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01278">1278</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab04f4d4643b5de9638d2f5aaa31d94e5" name="ab04f4d4643b5de9638d2f5aaa31d94e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04f4d4643b5de9638d2f5aaa31d94e5">&#9670;&#160;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_local_iterator <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01280">1280</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac2aca480ec930cab8cee31638ec6aa0c" name="ac2aca480ec930cab8cee31638ec6aa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aca480ec930cab8cee31638ec6aa0c">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_pointer <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01274">1274</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a580c722f453604f50c163788a75fd6c3" name="a580c722f453604f50c163788a75fd6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580c722f453604f50c163788a75fd6c3">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_reference <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01276">1276</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab91e542e87512944adfb13fcff51d7c8" name="ab91e542e87512944adfb13fcff51d7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91e542e87512944adfb13fcff51d7c8">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::difference_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01282">1282</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a8a087ced0dd9a5d8e57c101627b67fb6" name="a8a087ced0dd9a5d8e57c101627b67fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a087ced0dd9a5d8e57c101627b67fb6">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::hasher <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::hasher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01266">1266</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0fffce26090303390cc7fce06b5f6615" name="a0fffce26090303390cc7fce06b5f6615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fffce26090303390cc7fce06b5f6615">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::iterator <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01277">1277</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="afabc6af09a31459a08760bcec32a0b6d" name="afabc6af09a31459a08760bcec32a0b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabc6af09a31459a08760bcec32a0b6d">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_equal <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_equal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01267">1267</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae371392b325c1cdecb9bfdb891ee9fb0" name="ae371392b325c1cdecb9bfdb891ee9fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae371392b325c1cdecb9bfdb891ee9fb0">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01263">1263</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a8cb5d0ca110f847b3fceed2d07472710" name="a8cb5d0ca110f847b3fceed2d07472710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb5d0ca110f847b3fceed2d07472710">&#9670;&#160;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::local_iterator <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01279">1279</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a3e1544ab885cd443cf557eb35db830e8" name="a3e1544ab885cd443cf557eb35db830e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1544ab885cd443cf557eb35db830e8">&#9670;&#160;</a></span>mapped_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::mapped_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::mapped_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01265">1265</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae2c81650686b3dda757789b242919626" name="ae2c81650686b3dda757789b242919626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c81650686b3dda757789b242919626">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">using</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::node_type =  <a class="el" href="a09261.html">typename</a> _Hashtable::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01286">1286</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa9c05aec6bb3f18770d191869543334a" name="aa9c05aec6bb3f18770d191869543334a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c05aec6bb3f18770d191869543334a">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::pointer <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01273">1273</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a08487e5381fd61795c61cfa0fed8e48f" name="a08487e5381fd61795c61cfa0fed8e48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08487e5381fd61795c61cfa0fed8e48f">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::reference <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01275">1275</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ab9e187c541bf3fe290dd21b514abd024" name="ab9e187c541bf3fe290dd21b514abd024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9e187c541bf3fe290dd21b514abd024">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::size_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01281">1281</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4baa45433c393ecfab2c784b8de381e8" name="a4baa45433c393ecfab2c784b8de381e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4baa45433c393ecfab2c784b8de381e8">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::value_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01264">1264</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a722b99e1c15c3f0538bb6e2a2df15c32" name="a722b99e1c15c3f0538bb6e2a2df15c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722b99e1c15c3f0538bb6e2a2df15c32">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a4afc31e2217e4e10c6c821d38d9fa668" name="a4afc31e2217e4e10c6c821d38d9fa668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afc31e2217e4e10c6c821d38d9fa668">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Mnimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01302">1302</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a94fbf8cd5ee67d47203f4a01bb2d6568" name="a94fbf8cd5ee67d47203f4a01bb2d6568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fbf8cd5ee67d47203f4a01bb2d6568">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_multimap from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_multimap consisting of copies of the elements from [__first,__last). This is linear in N (where N is distance(__first,__last)). </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01323">1323</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af3d147e18b9233f333c7cd4921fc4aa7" name="af3d147e18b9233f333c7cd4921fc4aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d147e18b9233f333c7cd4921fc4aa7">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ab70b33e6e61485413fcb3bd22ac6d4ee" name="ab70b33e6e61485413fcb3bd22ac6d4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70b33e6e61485413fcb3bd22ac6d4ee">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="ab7ecc0576cd505fe517ffbbae066d3d6" name="ab7ecc0576cd505fe517ffbbae066d3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ecc0576cd505fe517ffbbae066d3d6">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unordered_multimap with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01342">1342</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a6f4788216736d2ae3a9b9452b4548ab3" name="a6f4788216736d2ae3a9b9452b4548ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4788216736d2ae3a9b9452b4548ab3">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__ummap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01351">1351</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4120fbcae709a132d7fb242884eba762" name="a4120fbcae709a132d7fb242884eba762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4120fbcae709a132d7fb242884eba762">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__ummap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01361">1361</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa11b69676f9f379ea2274cd722fae38d" name="aa11b69676f9f379ea2274cd722fae38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b69676f9f379ea2274cd722fae38d">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_multimap from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_multimap consisting of copies of the elements in the list. This is linear in N (where N is <em>__l.size()</em>). </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01378">1378</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a00f0e220345bda3d301875be9dfe7ea2" name="a00f0e220345bda3d301875be9dfe7ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f0e220345bda3d301875be9dfe7ea2">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01386">1386</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a6c7a7cfad4ac8c46618a5fe65c641bf7" name="a6c7a7cfad4ac8c46618a5fe65c641bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7a7cfad4ac8c46618a5fe65c641bf7">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01390">1390</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0ad1e3e0bcd96580607c8dbbe9853341" name="a0ad1e3e0bcd96580607c8dbbe9853341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad1e3e0bcd96580607c8dbbe9853341">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01396">1396</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a8947ad5828084f1eb618f7513f0074f6" name="a8947ad5828084f1eb618f7513f0074f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8947ad5828084f1eb618f7513f0074f6">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01403">1403</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a1a00ef1d495e73e9ce1ef805e005db97" name="a1a00ef1d495e73e9ce1ef805e005db97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00ef1d495e73e9ce1ef805e005db97">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01409">1409</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a03d4c0a0d0bff8a138a8aba24ed49955" name="a03d4c0a0d0bff8a138a8aba24ed49955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d4c0a0d0bff8a138a8aba24ed49955">&#9670;&#160;</a></span>unordered_multimap() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_multimap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01415">1415</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1fd8297776af120bf58bb6252562fc35" name="a1fd8297776af120bf58bb6252562fc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd8297776af120bf58bb6252562fc35">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01485">1485</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a1e8a71d9534d9f9cf27de31a025a3053" name="a1e8a71d9534d9f9cf27de31a025a3053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8a71d9534d9f9cf27de31a025a3053">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points to the first element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01476">1476</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a72025b859653a260f7e14bac43feae79" name="a72025b859653a260f7e14bac43feae79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72025b859653a260f7e14bac43feae79">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a8cb5d0ca110f847b3fceed2d07472710">local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read/write local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01948">1948</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aabce46436201e63f88dbebc168f9d84a" name="aabce46436201e63f88dbebc168f9d84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabce46436201e63f88dbebc168f9d84a">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01959">1959</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0af8e0bde2da18a7c91c256a60e02bf6" name="a0af8e0bde2da18a7c91c256a60e02bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af8e0bde2da18a7c91c256a60e02bf6">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01938">1938</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0c57013bd56a6fc373659c4e5807a64d" name="a0c57013bd56a6fc373659c4e5807a64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c57013bd56a6fc373659c4e5807a64d">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buckets of the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01915">1915</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac669fa17538b9e96dd43a9ed59de8ba0" name="ac669fa17538b9e96dd43a9ed59de8ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac669fa17538b9e96dd43a9ed59de8ba0">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01929">1929</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ae1c99977950ad720b2b10f6daf6c31ab" name="ae1c99977950ad720b2b10f6daf6c31ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c99977950ad720b2b10f6daf6c31ab">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01489">1489</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ad4f2132ee625dc5b3a48d28a495d552f" name="ad4f2132ee625dc5b3a48d28a495d552f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4f2132ee625dc5b3a48d28a495d552f">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01963">1963</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="acc5c6d3a39a12f7d21e8886534eaa591" name="acc5c6d3a39a12f7d21e8886534eaa591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5c6d3a39a12f7d21e8886534eaa591">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01511">1511</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00689_source.html#l01666">std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::insert()</a>.</p>

</div>
</div>
<a id="aeabc377e8c2f5b367388ee5e4e0aff99" name="aeabc377e8c2f5b367388ee5e4e0aff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabc377e8c2f5b367388ee5e4e0aff99">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01989">1989</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a96159c845937ab5729b5ed41a7ef6071" name="a96159c845937ab5729b5ed41a7ef6071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96159c845937ab5729b5ed41a7ef6071">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in an unordered_multimap. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01740">1740</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac5d31de17a110aa64b512196a80270de" name="ac5d31de17a110aa64b512196a80270de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d31de17a110aa64b512196a80270de">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x), <a class="el" href="a09261.html">void</a>(), <a class="el" href="a09261.html">true</a>)
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01873">1873</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4f74897455d878fc8ae828482038513d" name="a4f74897455d878fc8ae828482038513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f74897455d878fc8ae828482038513d">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01868">1868</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa1723fa0dcc14342665b4a370c89065d" name="aa1723fa0dcc14342665b4a370c89065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1723fa0dcc14342665b4a370c89065d">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_count_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01855">1855</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a323e46db071ea6d46dca69efbbc4d075" name="a323e46db071ea6d46dca69efbbc4d075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323e46db071ea6d46dca69efbbc4d075">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01849">1849</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4d00357a4ca15a9cdffa4aef992859c8" name="a4d00357a4ca15a9cdffa4aef992859c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d00357a4ca15a9cdffa4aef992859c8">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>This function attempts to build and insert a (key, value) pair into the unordered_multimap.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01534">1534</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af7f415a309a77497c41538b60d358fed" name="af7f415a309a77497c41538b60d358fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f415a309a77497c41538b60d358fed">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate a new pair instance (see std::piecewise_contruct for passing arguments to each part of the pair constructor). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of the std::pair built from <em>__args</em>.</dd></dl>
<p>Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01561">1561</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ada14f82918a4a9fcfaf3c4ce218d1e70" name="ada14f82918a4a9fcfaf3c4ce218d1e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada14f82918a4a9fcfaf3c4ce218d1e70">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the unordered_multimap is empty. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01456">1456</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0921ff9d001238f2f5b92f025378a37d" name="a0921ff9d001238f2f5b92f025378a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0921ff9d001238f2f5b92f025378a37d">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01507">1507</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a708a8efab9b1b9d8f1e41ca3ae2caaa5" name="a708a8efab9b1b9d8f1e41ca3ae2caaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708a8efab9b1b9d8f1e41ca3ae2caaa5">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read/write iterator that points one past the last element in the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01498">1498</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00689_source.html#l01653">std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::extract()</a>.</p>

</div>
</div>
<a id="a4209ed9ce2c4549ded624445fa59416f" name="a4209ed9ce2c4549ded624445fa59416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4209ed9ce2c4549ded624445fa59416f">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a8cb5d0ca110f847b3fceed2d07472710">local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read/write iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read/write local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01974">1974</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa7cd9ddc32c88838cfcd1f2cc53ae5ab" name="aa7cd9ddc32c88838cfcd1f2cc53ae5ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd9ddc32c88838cfcd1f2cc53ae5ab">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab04f4d4643b5de9638d2f5aaa31d94e5">const_local_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01985">1985</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af994cd522ccb97aae1122cf170f57591" name="af994cd522ccb97aae1122cf170f57591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af994cd522ccb97aae1122cf170f57591">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01893">1893</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aff76d30a0860ad9acde10b74d794621a" name="aff76d30a0860ad9acde10b74d794621a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff76d30a0860ad9acde10b74d794621a">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01905">1905</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a0b571a73d2cfd776608b01bede707492" name="a0b571a73d2cfd776608b01bede707492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b571a73d2cfd776608b01bede707492">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01887">1887</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a946c0b814290c4c507a7188cd2bb65dc" name="a946c0b814290c4c507a7188cd2bb65dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946c0b814290c4c507a7188cd2bb65dc">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>, <a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> &gt; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01899">1899</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a09397dfd53f29fdbc8809d37ab11b142" name="a09397dfd53f29fdbc8809d37ab11b142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09397dfd53f29fdbc8809d37ab11b142">&#9670;&#160;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased.</dd></dl>
<p>This function erases all the elements located by the given key from an unordered_multimap. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01711">1711</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aa38e97c00a7b10fb37726206ebc57800" name="aa38e97c00a7b10fb37726206ebc57800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38e97c00a7b10fb37726206ebc57800">&#9670;&#160;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a [__first,__last) range of elements from an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator <em>__last</em>.</dd></dl>
<p>This function erases a sequence of elements from an unordered_multimap. Note that this function only erases the elements, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01730">1730</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a671564fa7d5dd0e04b651e78861c89ba" name="a671564fa7d5dd0e04b651e78861c89ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671564fa7d5dd0e04b651e78861c89ba">&#9670;&#160;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_multimap. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01690">1690</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a08eec5ee5f497c48d356443110934fdd" name="a08eec5ee5f497c48d356443110934fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08eec5ee5f497c48d356443110934fdd">&#9670;&#160;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_multimap. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01695">1695</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4d61c0eb6737c76b2e77c9ab37ef2acd" name="a4d61c0eb6737c76b2e77c9ab37ef2acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d61c0eb6737c76b2e77c9ab37ef2acd">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01661">1661</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aea03e4d3fc99980d93c352d9be43dca6" name="aea03e4d3fc99980d93c352d9be43dca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea03e4d3fc99980d93c352d9be43dca6">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01653">1653</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00689_source.html#l01498">std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a41564272341ae36b4955b6c439115ccc" name="a41564272341ae36b4955b6c439115ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41564272341ae36b4955b6c439115ccc">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01826">1826</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aaeddd1f13087ca78351420edf2a149b4" name="aaeddd1f13087ca78351420edf2a149b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeddd1f13087ca78351420edf2a149b4">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(__x))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01837">1837</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a9f64e8fbc46b2fec76e96499ac91c8b6" name="a9f64e8fbc46b2fec76e96499ac91c8b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f64e8fbc46b2fec76e96499ac91c8b6">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01820">1820</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a3a54562ef76d4966a496b86691fdfb12" name="a3a54562ef76d4966a496b86691fdfb12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a54562ef76d4966a496b86691fdfb12">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#ae371392b325c1cdecb9bfdb891ee9fb0">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01831">1831</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="afb20a72b3b3284f980ec948c79e3b59d" name="afb20a72b3b3284f980ec948c79e3b59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb20a72b3b3284f980ec948c79e3b59d">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#aab5213cbfd6797faef226b949240b8ec">allocator_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator object used by the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01449">1449</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a208a268d709e23f97d5763d2f24de4f2" name="a208a268d709e23f97d5763d2f24de4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208a268d709e23f97d5763d2f24de4f2">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a8a087ced0dd9a5d8e57c101627b67fb6">hasher</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash functor object with which the unordered_multimap was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01796">1796</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a46f035c31a44c4051965af7868d40e77" name="a46f035c31a44c4051965af7868d40e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f035c31a44c4051965af7868d40e77">&#9670;&#160;</a></span>insert() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A template function that attempts to insert a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01635">1635</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac3b6ae5420b725091adca9268a43900f" name="ac3b6ae5420b725091adca9268a43900f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b6ae5420b725091adca9268a43900f">&#9670;&#160;</a></span>insert() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pair</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt; <a class="el" href="a04005.html">is_constructible</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a>, <a class="el" href="a09261.html">_Pair</a> &amp;&amp; &gt;::value, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_Pair</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01584">1584</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a79303f819716015a95be11962dda3e53" name="a79303f819716015a95be11962dda3e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79303f819716015a95be11962dda3e53">&#9670;&#160;</a></span>insert() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01575">1575</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a246ef63aba02155fc1cf43edfe84cf84" name="a246ef63aba02155fc1cf43edfe84cf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246ef63aba02155fc1cf43edfe84cf84">&#9670;&#160;</a></span>insert() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pair</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__enable_if_t&lt; <a class="el" href="a04005.html">is_constructible</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a>, <a class="el" href="a09261.html">_Pair</a> &amp;&amp; &gt;::value, <a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> &gt; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_Pair</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01620">1620</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="aeb4625ec1e0a22af00ccb220e4c7c7b2" name="aeb4625ec1e0a22af00ccb220e4c7c7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4625ec1e0a22af00ccb220e4c7c7b2">&#9670;&#160;</a></span>insert() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01609">1609</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a212cc153aa0e4404d73ff85711aa98b5" name="a212cc153aa0e4404d73ff85711aa98b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212cc153aa0e4404d73ff85711aa98b5">&#9670;&#160;</a></span>insert() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01671">1671</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="af90dcd39d44bdeffe788e78ca829d639" name="af90dcd39d44bdeffe788e78ca829d639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90dcd39d44bdeffe788e78ca829d639">&#9670;&#160;</a></span>insert() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ac98a77485a1a68eaadb6a7c8b5d4b141">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the pair should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the pair passed in).</dd></dl>
<p>Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>See <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a> for more on <em>hinting</em>.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01615">1615</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="acb1935806673ced5dae48aa64d8cabc3" name="acb1935806673ced5dae48aa64d8cabc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1935806673ced5dae48aa64d8cabc3">&#9670;&#160;</a></span>insert() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a list of elements into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>A std::initializer_list&lt;value_type&gt; of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01647">1647</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a5b1a926a6d12e51f5ab00abeb26e83cf" name="a5b1a926a6d12e51f5ab00abeb26e83cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1a926a6d12e51f5ab00abeb26e83cf">&#9670;&#160;</a></span>insert() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01666">1666</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00689_source.html#l01511">std::unordered_multimap&lt; _Key, _Tp, _Hash, _Pred, _Alloc &gt;::cend()</a>, and <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="a73f5c66280686af351a204b1d98774b6" name="a73f5c66280686af351a204b1d98774b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f5c66280686af351a204b1d98774b6">&#9670;&#160;</a></span>insert() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#a0fffce26090303390cc7fce06b5f6615">iterator</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a std::pair into the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Pair to be inserted (see std::make_pair for easy creation of pairs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the inserted pair.</dd></dl>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01579">1579</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="a32226343bc7c4b8b0b14914fd3d105cb" name="a32226343bc7c4b8b0b14914fd3d105cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32226343bc7c4b8b0b14914fd3d105cb">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#afabc6af09a31459a08760bcec32a0b6d">key_equal</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key comparison object with which the unordered_multimap was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01802">1802</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a02888ba9dce21c5e16ba09734ebdb642" name="a02888ba9dce21c5e16ba09734ebdb642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02888ba9dce21c5e16ba09734ebdb642">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the average number of elements per bucket. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01997">1997</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a193e48c36ac0f5888911cf991428a287" name="a193e48c36ac0f5888911cf991428a287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193e48c36ac0f5888911cf991428a287">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of buckets of the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01920">1920</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a72250fbcb87cc6ea4998eb8f00465650" name="a72250fbcb87cc6ea4998eb8f00465650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72250fbcb87cc6ea4998eb8f00465650">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a positive number that the unordered_multimap tries to keep the load factor less than or equal to. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l02003">2003</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="afea08a0d2315df4b6da1318c74be7114" name="afea08a0d2315df4b6da1318c74be7114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea08a0d2315df4b6da1318c74be7114">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>__z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the unordered_multimap maximum load factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__z</td><td>The new maximum load factor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l02011">2011</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="accd0a24f61c8161dbd0fe216ead19142" name="accd0a24f61c8161dbd0fe216ead19142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd0a24f61c8161dbd0fe216ead19142">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum size of the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01466">1466</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a6031be71a267c406b2e03471565be797" name="a6031be71a267c406b2e03471565be797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6031be71a267c406b2e03471565be797">&#9670;&#160;</a></span>merge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08769.html">unordered_map</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01787">1787</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ad113c08ea4c87c7f3413fd999ac5ff05" name="ad113c08ea4c87c7f3413fd999ac5ff05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad113c08ea4c87c7f3413fd999ac5ff05">&#9670;&#160;</a></span>merge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08769.html">unordered_map</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01778">1778</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a4bdc22e9ef58e2074ee1a9b4375faedc" name="a4bdc22e9ef58e2074ee1a9b4375faedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdc22e9ef58e2074ee1a9b4375faedc">&#9670;&#160;</a></span>merge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01773">1773</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a1aabe74fe7d7e84f2cafa3f8175b1dd5" name="a1aabe74fe7d7e84f2cafa3f8175b1dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aabe74fe7d7e84f2cafa3f8175b1dd5">&#9670;&#160;</a></span>merge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01764">1764</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a308ed5b6c114249a5353787d9ed05969" name="a308ed5b6c114249a5353787d9ed05969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308ed5b6c114249a5353787d9ed05969">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">unordered_multimap</a> &amp; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a4ad305e11611aa4ca5f9315de388f4a6" name="a4ad305e11611aa4ca5f9315de388f4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad305e11611aa4ca5f9315de388f4a6">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">unordered_multimap</a> &amp; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08765.html#a4baa45433c393ecfab2c784b8de381e8">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unordered_multimap list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills an unordered_multimap with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the unordered_multimap and that the resulting unordered_multimap's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01441">1441</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a80e6f88c35b73121fb317d132e38672d" name="a80e6f88c35b73121fb317d132e38672d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e6f88c35b73121fb317d132e38672d">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html">unordered_multimap</a> &amp; <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="ac9032d22474fc3c5ec4d0b74362b5f4e" name="ac9032d22474fc3c5ec4d0b74362b5f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9032d22474fc3c5ec4d0b74362b5f4e">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May rehash the unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The new number of buckets.</td></tr>
  </table>
  </dd>
</dl>
<p>Rehash will occur only if the new number of buckets respect the unordered_multimap maximum load factor. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l02022">2022</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="a9167538c4058279e45627d0a68f3d030" name="a9167538c4058279e45627d0a68f3d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9167538c4058279e45627d0a68f3d030">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the unordered_multimap for a specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements required.</td></tr>
  </table>
  </dd>
</dl>
<p>Same as rehash(ceil(n / max_load_factor())). </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l02033">2033</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="af02efb64c18107a5c4f13a1983cfa5a3" name="af02efb64c18107a5c4f13a1983cfa5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02efb64c18107a5c4f13a1983cfa5a3">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08765.html#ab9e187c541bf3fe290dd21b514abd024">size_type</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the unordered_multimap. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01461">1461</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<a id="ac8d3f27e1315796ddcc9b55378f90ce7" name="ac8d3f27e1315796ddcc9b55378f90ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d3f27e1315796ddcc9b55378f90ce7">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08765.html">std::unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08765.html">unordered_multimap</a>&lt; <a class="el" href="a09261.html">_Key</a>, _Tp, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another unordered_multimap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>An unordered_multimap of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two unordered_multimap in constant time. Note that the global std::swap() function is specialized such that std::swap(m1,m2) will feed to this function. </p>

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01754">1754</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af0ba6094bfef194c2c3895c5ea1efa6d" name="af0ba6094bfef194c2c3895c5ea1efa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba6094bfef194c2c3895c5ea1efa6d">&#9670;&#160;</a></span>std::_Hash_merge_helper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Key</a> , <a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Key&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;std::pair&lt;const _Key, _Tp&gt;&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="a09261.html">class</a> std::_Hash_merge_helper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00689_source.html#l01760">1760</a> of file <a class="el" href="a00689_source.html">unordered_map.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00689_source.html">unordered_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01663.html">std</a></li><li class="navelem"><a class="el" href="a08765.html">unordered_multimap</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>

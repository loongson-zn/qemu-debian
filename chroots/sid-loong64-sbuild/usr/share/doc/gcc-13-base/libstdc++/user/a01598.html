<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: Mutating</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01598.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Mutating<div class="ingroups"><a class="el" href="a01597.html">Algorithms</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mutating:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01598.svg" width="222" height="35"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga76cd6d1a042c96e883b2fed2d16bdce2" id="r_ga76cd6d1a042c96e883b2fed2d16bdce2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> &gt; </td></tr>
<tr class="memitem:ga76cd6d1a042c96e883b2fed2d16bdce2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_OI</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga76cd6d1a042c96e883b2fed2d16bdce2">std::copy</a> (<a class="el" href="a09261.html">_II</a> __first, <a class="el" href="a09261.html">_II</a> __last, <a class="el" href="a09261.html">_OI</a> __result)</td></tr>
<tr class="separator:ga76cd6d1a042c96e883b2fed2d16bdce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cb383fd3bfaf0a68d886a1ac7f246f" id="r_gad6cb383fd3bfaf0a68d886a1ac7f246f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI2</a> &gt; </td></tr>
<tr class="memitem:gad6cb383fd3bfaf0a68d886a1ac7f246f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_BI2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gad6cb383fd3bfaf0a68d886a1ac7f246f">std::copy_backward</a> (<a class="el" href="a09261.html">_BI1</a> __first, <a class="el" href="a09261.html">_BI1</a> __last, <a class="el" href="a09261.html">_BI2</a> __result)</td></tr>
<tr class="separator:gad6cb383fd3bfaf0a68d886a1ac7f246f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f99a17b2ea1ef3c5383baf211eba03e" id="r_ga5f99a17b2ea1ef3c5383baf211eba03e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga5f99a17b2ea1ef3c5383baf211eba03e"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga5f99a17b2ea1ef3c5383baf211eba03e">std::copy_if</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga5f99a17b2ea1ef3c5383baf211eba03e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga637f091d55c988fe8347446337f6de47" id="r_ga637f091d55c988fe8347446337f6de47"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </td></tr>
<tr class="memitem:ga637f091d55c988fe8347446337f6de47"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga637f091d55c988fe8347446337f6de47">std::copy_n</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, _Size __n, _OutputIterator __result)</td></tr>
<tr class="separator:ga637f091d55c988fe8347446337f6de47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134fa4440441a428ac3e792633d537f6" id="r_ga134fa4440441a428ac3e792633d537f6"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:ga134fa4440441a428ac3e792633d537f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga134fa4440441a428ac3e792633d537f6">std::fill</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, const _Tp &amp;__value)</td></tr>
<tr class="separator:ga134fa4440441a428ac3e792633d537f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec50b0b878a1178418bad7ea70add994" id="r_gaec50b0b878a1178418bad7ea70add994"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gaec50b0b878a1178418bad7ea70add994"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_OI</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gaec50b0b878a1178418bad7ea70add994">std::fill_n</a> (<a class="el" href="a09261.html">_OI</a> __first, _Size __n, const _Tp &amp;__value)</td></tr>
<tr class="separator:gaec50b0b878a1178418bad7ea70add994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74c6d3ba1f5667d3efa65784096ad57" id="r_gab74c6d3ba1f5667d3efa65784096ad57"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Generator</a> &gt; </td></tr>
<tr class="memitem:gab74c6d3ba1f5667d3efa65784096ad57"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gab74c6d3ba1f5667d3efa65784096ad57">std::generate</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, <a class="el" href="a09261.html">_Generator</a> <a class="el" href="a09261.html">__gen</a>)</td></tr>
<tr class="separator:gab74c6d3ba1f5667d3efa65784096ad57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32129cb793a15f89f2c8df8631bfcaee" id="r_ga32129cb793a15f89f2c8df8631bfcaee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Generator</a> &gt; </td></tr>
<tr class="memitem:ga32129cb793a15f89f2c8df8631bfcaee"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga32129cb793a15f89f2c8df8631bfcaee">std::generate_n</a> (_OutputIterator __first, _Size __n, <a class="el" href="a09261.html">_Generator</a> <a class="el" href="a09261.html">__gen</a>)</td></tr>
<tr class="separator:ga32129cb793a15f89f2c8df8631bfcaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6777120ebee50005d9b44e53dbeb35" id="r_ga4b6777120ebee50005d9b44e53dbeb35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga4b6777120ebee50005d9b44e53dbeb35"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga4b6777120ebee50005d9b44e53dbeb35">std::is_partitioned</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga4b6777120ebee50005d9b44e53dbeb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a4776ef39f6174250c03233358482df" id="r_ga1a4776ef39f6174250c03233358482df"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator2</a> &gt; </td></tr>
<tr class="memitem:ga1a4776ef39f6174250c03233358482df"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga1a4776ef39f6174250c03233358482df">std::iter_swap</a> (<a class="el" href="a09261.html">_ForwardIterator1</a> __a, <a class="el" href="a09261.html">_ForwardIterator2</a> __b)</td></tr>
<tr class="separator:ga1a4776ef39f6174250c03233358482df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac49c576614909405700e37ae1f48a946" id="r_gac49c576614909405700e37ae1f48a946"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> &gt; </td></tr>
<tr class="memitem:gac49c576614909405700e37ae1f48a946"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_OI</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gac49c576614909405700e37ae1f48a946">std::move</a> (<a class="el" href="a09261.html">_II</a> __first, <a class="el" href="a09261.html">_II</a> __last, <a class="el" href="a09261.html">_OI</a> __result)</td></tr>
<tr class="separator:gac49c576614909405700e37ae1f48a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2059ffdbdafd630dc5d7071295f8287" id="r_gae2059ffdbdafd630dc5d7071295f8287"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI2</a> &gt; </td></tr>
<tr class="memitem:gae2059ffdbdafd630dc5d7071295f8287"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_BI2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gae2059ffdbdafd630dc5d7071295f8287">std::move_backward</a> (<a class="el" href="a09261.html">_BI1</a> __first, <a class="el" href="a09261.html">_BI1</a> __last, <a class="el" href="a09261.html">_BI2</a> __result)</td></tr>
<tr class="separator:gae2059ffdbdafd630dc5d7071295f8287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8d031e65e4307c571526e0bd9a04e8" id="r_gadc8d031e65e4307c571526e0bd9a04e8"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:gadc8d031e65e4307c571526e0bd9a04e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gadc8d031e65e4307c571526e0bd9a04e8">std::partition</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:gadc8d031e65e4307c571526e0bd9a04e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad786dd953c3c6ad4b64217ac914d8a9e" id="r_gad786dd953c3c6ad4b64217ac914d8a9e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OutputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OutputIterator2</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:gad786dd953c3c6ad4b64217ac914d8a9e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_OutputIterator1</a>, <a class="el" href="a09261.html">_OutputIterator2</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gad786dd953c3c6ad4b64217ac914d8a9e">std::partition_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a09261.html">_OutputIterator1</a> <a class="el" href="a09261.html">__out_true</a>, <a class="el" href="a09261.html">_OutputIterator2</a> <a class="el" href="a09261.html">__out_false</a>, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:gad786dd953c3c6ad4b64217ac914d8a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67728ba609039bfa4b90283f8a8e79a1" id="r_ga67728ba609039bfa4b90283f8a8e79a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga67728ba609039bfa4b90283f8a8e79a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga67728ba609039bfa4b90283f8a8e79a1">std::partition_point</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga67728ba609039bfa4b90283f8a8e79a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695aabc23dc8890aab28a155a13e9fa5" id="r_ga695aabc23dc8890aab28a155a13e9fa5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </td></tr>
<tr class="memitem:ga695aabc23dc8890aab28a155a13e9fa5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga695aabc23dc8890aab28a155a13e9fa5">std::random_shuffle</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last)</td></tr>
<tr class="separator:ga695aabc23dc8890aab28a155a13e9fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4e555bd94a923ad7d263703b4ab2bc" id="r_gabf4e555bd94a923ad7d263703b4ab2bc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomNumberGenerator</a> &gt; </td></tr>
<tr class="memitem:gabf4e555bd94a923ad7d263703b4ab2bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gabf4e555bd94a923ad7d263703b4ab2bc">std::random_shuffle</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, <a class="el" href="a09261.html">_RandomNumberGenerator</a> &amp;&amp;<a class="el" href="a09261.html">__rand</a>)</td></tr>
<tr class="separator:gabf4e555bd94a923ad7d263703b4ab2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ec72c0c6dc0ee8996066b5e50bc472" id="r_gae6ec72c0c6dc0ee8996066b5e50bc472"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gae6ec72c0c6dc0ee8996066b5e50bc472"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gae6ec72c0c6dc0ee8996066b5e50bc472">std::remove</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, const _Tp &amp;__value)</td></tr>
<tr class="separator:gae6ec72c0c6dc0ee8996066b5e50bc472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a1b13efaaeecca3d010d942c9ce7a1" id="r_ga86a1b13efaaeecca3d010d942c9ce7a1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:ga86a1b13efaaeecca3d010d942c9ce7a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga86a1b13efaaeecca3d010d942c9ce7a1">std::remove_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, const _Tp &amp;__value)</td></tr>
<tr class="separator:ga86a1b13efaaeecca3d010d942c9ce7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga503c001bc1c1d80fe79c7045396faf73" id="r_ga503c001bc1c1d80fe79c7045396faf73"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga503c001bc1c1d80fe79c7045396faf73"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga503c001bc1c1d80fe79c7045396faf73">std::remove_copy_if</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga503c001bc1c1d80fe79c7045396faf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bdd7c382561d1d749f4e129658e18a5" id="r_ga7bdd7c382561d1d749f4e129658e18a5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga7bdd7c382561d1d749f4e129658e18a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga7bdd7c382561d1d749f4e129658e18a5">std::remove_if</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga7bdd7c382561d1d749f4e129658e18a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8637a7be56ce2578b83682a3fdf0ee" id="r_gaaa8637a7be56ce2578b83682a3fdf0ee"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gaaa8637a7be56ce2578b83682a3fdf0ee"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gaaa8637a7be56ce2578b83682a3fdf0ee">std::replace</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, const _Tp &amp;<a class="el" href="a09261.html">__old_value</a>, const _Tp &amp;<a class="el" href="a09261.html">__new_value</a>)</td></tr>
<tr class="separator:gaaa8637a7be56ce2578b83682a3fdf0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84edecb0fb1d0e5cf847a55fd74634f" id="r_gac84edecb0fb1d0e5cf847a55fd74634f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gac84edecb0fb1d0e5cf847a55fd74634f"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gac84edecb0fb1d0e5cf847a55fd74634f">std::replace_copy_if</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, _Predicate <a class="el" href="a09261.html">__pred</a>, const _Tp &amp;<a class="el" href="a09261.html">__new_value</a>)</td></tr>
<tr class="separator:gac84edecb0fb1d0e5cf847a55fd74634f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26921bd1b038b5ef5dcd40f024c12e2" id="r_gae26921bd1b038b5ef5dcd40f024c12e2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate , <a class="el" href="a09261.html">typename</a> _Tp &gt; </td></tr>
<tr class="memitem:gae26921bd1b038b5ef5dcd40f024c12e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gae26921bd1b038b5ef5dcd40f024c12e2">std::replace_if</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>, const _Tp &amp;<a class="el" href="a09261.html">__new_value</a>)</td></tr>
<tr class="separator:gae26921bd1b038b5ef5dcd40f024c12e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e7ff99a606d89406c0a9f5ec215b041" id="r_ga8e7ff99a606d89406c0a9f5ec215b041"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </td></tr>
<tr class="memitem:ga8e7ff99a606d89406c0a9f5ec215b041"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga8e7ff99a606d89406c0a9f5ec215b041">std::reverse</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last)</td></tr>
<tr class="separator:ga8e7ff99a606d89406c0a9f5ec215b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20e081bb649e8d217b88c32236e29c02" id="r_ga20e081bb649e8d217b88c32236e29c02"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </td></tr>
<tr class="memitem:ga20e081bb649e8d217b88c32236e29c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga20e081bb649e8d217b88c32236e29c02">std::reverse_copy</a> (<a class="el" href="a09261.html">_BidirectionalIterator</a> __first, <a class="el" href="a09261.html">_BidirectionalIterator</a> __last, _OutputIterator __result)</td></tr>
<tr class="separator:ga20e081bb649e8d217b88c32236e29c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7937b25672a5ce41d9f5a787fafe35" id="r_gabb7937b25672a5ce41d9f5a787fafe35"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:gabb7937b25672a5ce41d9f5a787fafe35"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gabb7937b25672a5ce41d9f5a787fafe35">std::rotate</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __middle, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:gabb7937b25672a5ce41d9f5a787fafe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46dd8941091696e7b653044da57a11e1" id="r_ga46dd8941091696e7b653044da57a11e1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </td></tr>
<tr class="memitem:ga46dd8941091696e7b653044da57a11e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga46dd8941091696e7b653044da57a11e1">std::rotate_copy</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __middle, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _OutputIterator __result)</td></tr>
<tr class="separator:ga46dd8941091696e7b653044da57a11e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c197f83f8612241f91e0a44703fdeaf" id="r_ga9c197f83f8612241f91e0a44703fdeaf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_UniformRandomNumberGenerator</a> &gt; </td></tr>
<tr class="memitem:ga9c197f83f8612241f91e0a44703fdeaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga9c197f83f8612241f91e0a44703fdeaf">std::shuffle</a> (<a class="el" href="a09261.html">_RandomAccessIterator</a> __first, <a class="el" href="a09261.html">_RandomAccessIterator</a> __last, <a class="el" href="a09261.html">_UniformRandomNumberGenerator</a> &amp;&amp;<a class="el" href="a09261.html">__g</a>)</td></tr>
<tr class="separator:ga9c197f83f8612241f91e0a44703fdeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4396b91f26c7aaf0ae150a79ebd965b7" id="r_ga4396b91f26c7aaf0ae150a79ebd965b7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </td></tr>
<tr class="memitem:ga4396b91f26c7aaf0ae150a79ebd965b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga4396b91f26c7aaf0ae150a79ebd965b7">std::stable_partition</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, _Predicate <a class="el" href="a09261.html">__pred</a>)</td></tr>
<tr class="separator:ga4396b91f26c7aaf0ae150a79ebd965b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1b9a02d1ca7a1622e424d8d912c75bb" id="r_gaf1b9a02d1ca7a1622e424d8d912c75bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator2</a> &gt; </td></tr>
<tr class="memitem:gaf1b9a02d1ca7a1622e424d8d912c75bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gaf1b9a02d1ca7a1622e424d8d912c75bb">std::swap_ranges</a> (<a class="el" href="a09261.html">_ForwardIterator1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_ForwardIterator1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_ForwardIterator2</a> <a class="el" href="a09261.html">__first2</a>)</td></tr>
<tr class="separator:gaf1b9a02d1ca7a1622e424d8d912c75bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c943ad5f85ce0c2f69a074bb42591dd" id="r_ga8c943ad5f85ce0c2f69a074bb42591dd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_UnaryOperation</a> &gt; </td></tr>
<tr class="memitem:ga8c943ad5f85ce0c2f69a074bb42591dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga8c943ad5f85ce0c2f69a074bb42591dd">std::transform</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, <a class="el" href="a09261.html">_UnaryOperation</a> <a class="el" href="a09261.html">__unary_op</a>)</td></tr>
<tr class="separator:ga8c943ad5f85ce0c2f69a074bb42591dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef5a202b512e1d8a9a6e0a2739290bc1" id="r_gaef5a202b512e1d8a9a6e0a2739290bc1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryOperation</a> &gt; </td></tr>
<tr class="memitem:gaef5a202b512e1d8a9a6e0a2739290bc1"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gaef5a202b512e1d8a9a6e0a2739290bc1">std::transform</a> (<a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__first1</a>, <a class="el" href="a09261.html">_InputIterator1</a> <a class="el" href="a09261.html">__last1</a>, <a class="el" href="a09261.html">_InputIterator2</a> <a class="el" href="a09261.html">__first2</a>, _OutputIterator __result, <a class="el" href="a09261.html">_BinaryOperation</a> <a class="el" href="a09261.html">__binary_op</a>)</td></tr>
<tr class="separator:gaef5a202b512e1d8a9a6e0a2739290bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedeb9daeefd95379cf49b7e52cafc25" id="r_gabedeb9daeefd95379cf49b7e52cafc25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </td></tr>
<tr class="memitem:gabedeb9daeefd95379cf49b7e52cafc25"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#gabedeb9daeefd95379cf49b7e52cafc25">std::unique</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last)</td></tr>
<tr class="separator:gabedeb9daeefd95379cf49b7e52cafc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3e26d485c4745ffd5dc1ca26c35a78" id="r_ga7a3e26d485c4745ffd5dc1ca26c35a78"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryPredicate</a> &gt; </td></tr>
<tr class="memitem:ga7a3e26d485c4745ffd5dc1ca26c35a78"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga7a3e26d485c4745ffd5dc1ca26c35a78">std::unique</a> (<a class="el" href="a09261.html">_ForwardIterator</a> __first, <a class="el" href="a09261.html">_ForwardIterator</a> __last, <a class="el" href="a09261.html">_BinaryPredicate</a> <a class="el" href="a09261.html">__binary_pred</a>)</td></tr>
<tr class="separator:ga7a3e26d485c4745ffd5dc1ca26c35a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb85887d232506d4c3242cc3fff15a0" id="r_ga7bb85887d232506d4c3242cc3fff15a0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </td></tr>
<tr class="memitem:ga7bb85887d232506d4c3242cc3fff15a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga7bb85887d232506d4c3242cc3fff15a0">std::unique_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result)</td></tr>
<tr class="separator:ga7bb85887d232506d4c3242cc3fff15a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd1e4d1c78160b672f0c904fd3d2f89" id="r_ga1dd1e4d1c78160b672f0c904fd3d2f89"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryPredicate</a> &gt; </td></tr>
<tr class="memitem:ga1dd1e4d1c78160b672f0c904fd3d2f89"><td class="memTemplItemLeft" align="right" valign="top">constexpr _OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01598.html#ga1dd1e4d1c78160b672f0c904fd3d2f89">std::unique_copy</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, _OutputIterator __result, <a class="el" href="a09261.html">_BinaryPredicate</a> <a class="el" href="a09261.html">__binary_pred</a>)</td></tr>
<tr class="separator:ga1dd1e4d1c78160b672f0c904fd3d2f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga76cd6d1a042c96e883b2fed2d16bdce2" name="ga76cd6d1a042c96e883b2fed2d16bdce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76cd6d1a042c96e883b2fed2d16bdce2">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_OI</a> std::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_II</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_OI</a>&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result + (last - first)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). Result may not be contained within [first,last); the copy_backward function should be used instead.</p>
<p>Note that the end of the output range is permitted to be contained within [first,last). </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00624">624</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gad6cb383fd3bfaf0a68d886a1ac7f246f" name="gad6cb383fd3bfaf0a68d886a1ac7f246f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6cb383fd3bfaf0a68d886a1ac7f246f">&#9670;&#160;</a></span>copy_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_BI2</a> std::copy_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI1</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI1</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI2</a>&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result - (last - first)</dd></dl>
<p>The function has the same effect as copy, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling).</p>
<p>Result may not be in the range (first,last]. Use copy instead. Note that the start of the output range may overlap [first,last). </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00857">857</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga5f99a17b2ea1ef3c5383baf211eba03e" name="ga5f99a17b2ea1ef3c5383baf211eba03e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f99a17b2ea1ef3c5383baf211eba03e">&#9670;&#160;</a></span>copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns true to the range beginning at <code>__result</code>.</p>
<p>copy_if() is stable, so the relative order of elements that are copied is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00694">694</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga637f091d55c988fe8347446337f6de47" name="ga637f091d55c988fe8347446337f6de47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga637f091d55c988fe8347446337f6de47">&#9670;&#160;</a></span>copy_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::copy_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the range [first,first+n) into [result,result+n). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The number of elements to copy. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result+n.</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00749">749</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>.</p>

</div>
</div>
<a id="ga134fa4440441a428ac3e792633d537f6" name="ga134fa4440441a428ac3e792633d537f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134fa4440441a428ac3e792633d537f6">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the range [first,last) with copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or <code>wmemset</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l01000">1000</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gaec50b0b878a1178418bad7ea70add994" name="gaec50b0b878a1178418bad7ea70add994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec50b0b878a1178418bad7ea70add994">&#9670;&#160;</a></span>fill_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_OI</a> std::fill_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_OI</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the range [first,first+n) with copies of value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The count of copies to perform. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator at first+n.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or <code>wmemset</code>.</p>
<p>If <code>__n</code> is negative, the function does nothing. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l01152">1152</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>.</p>

</div>
</div>
<a id="gab74c6d3ba1f5667d3efa65784096ad57" name="gab74c6d3ba1f5667d3efa65784096ad57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab74c6d3ba1f5667d3efa65784096ad57">&#9670;&#160;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_Generator</a>&#160;</td>
          <td class="paramname"><em>__gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object callable with no arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i = __gen()</code> for each <code>i</code> in the range <code>[__first, __last)</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04434">4434</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga32129cb793a15f89f2c8df8631bfcaee" name="ga32129cb793a15f89f2c8df8631bfcaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32129cb793a15f89f2c8df8631bfcaee">&#9670;&#160;</a></span>generate_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Size , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Generator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::generate_n </td>
          <td>(</td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_Generator</a>&#160;</td>
          <td class="paramname"><em>__gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object callable with no arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the sequence, i.e., <code>__first + __n</code></dd></dl>
<p>Performs the assignment <code>*i = __gen()</code> for each <code>i</code> in the range <code>[__first, __first + __n)</code>.</p>
<p>If <code>__n</code> is negative, the function does nothing and returns <code>__first</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04467">4467</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga4b6777120ebee50005d9b44e53dbeb35" name="ga4b6777120ebee50005d9b44e53dbeb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b6777120ebee50005d9b44e53dbeb35">&#9670;&#160;</a></span>is_partitioned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool std::is_partitioned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the sequence is partitioned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the range <code></code>[__first,__last) is partioned by <code>__pred</code>, i.e. if all elements that satisfy <code>__pred</code> appear before those that do not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00536">536</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga1a4776ef39f6174250c03233358482df" name="ga1a4776ef39f6174250c03233358482df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a4776ef39f6174250c03233358482df">&#9670;&#160;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::iter_swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator1</a>&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator2</a>&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__b</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>This function swaps the values pointed to by two iterators, not the iterators themselves. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00155">155</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gac49c576614909405700e37ae1f48a946" name="gac49c576614909405700e37ae1f48a946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac49c576614909405700e37ae1f48a946">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_II</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OI</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_OI</a> std::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_II</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_II</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_OI</a>&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result + (last - first)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). Result may not be contained within [first,last); the move_backward function should be used instead.</p>
<p>Note that the end of the output range is permitted to be contained within [first,last). </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00657">657</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gae2059ffdbdafd630dc5d7071295f8287" name="gae2059ffdbdafd630dc5d7071295f8287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2059ffdbdafd630dc5d7071295f8287">&#9670;&#160;</a></span>move_backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BI2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_BI2</a> std::move_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI1</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI1</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BI2</a>&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the range [first,last) into result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result - (last - first)</dd></dl>
<p>The function has the same effect as move, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling).</p>
<p>Result may not be in the range (first,last]. Use move instead. Note that the start of the output range may overlap [first,last). </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00892">892</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="gadc8d031e65e4307c571526e0bd9a04e8" name="gadc8d031e65e4307c571526e0bd9a04e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc8d031e65e4307c571526e0bd9a04e8">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move elements for which a predicate is true to the beginning of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code>[__first, middle)</code> and false for each <code>i</code> in the range <code>[middle, __last)</code>.</dd></dl>
<p><code>__pred</code> must not modify its operand. <code>partition()</code> does not preserve the relative ordering of elements in each group, use <code>stable_partition()</code> if this is needed. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04662">4662</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>, and <a class="el" href="a00464_source.html#l01446">std::__partition()</a>.</p>

</div>
</div>
<a id="gad786dd953c3c6ad4b64217ac914d8a9e" name="gad786dd953c3c6ad4b64217ac914d8a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad786dd953c3c6ad4b64217ac914d8a9e">&#9670;&#160;</a></span>partition_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OutputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_OutputIterator2</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a08457.html">pair</a>&lt; <a class="el" href="a09261.html">_OutputIterator1</a>, <a class="el" href="a09261.html">_OutputIterator2</a> &gt; std::partition_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_OutputIterator1</a>&#160;</td>
          <td class="paramname"><em>__out_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_OutputIterator2</a>&#160;</td>
          <td class="paramname"><em>__out_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the elements of a sequence to separate output sequences depending on the truth value of a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__out_true</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__out_false</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair designating the ends of the resulting sequences.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns true to the range beginning at <code>out_true</code> and each element for which <code>__pred</code> returns false to <code>__out_false</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00786">786</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga67728ba609039bfa4b90283f8a8e79a1" name="ga67728ba609039bfa4b90283f8a8e79a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67728ba609039bfa4b90283f8a8e79a1">&#9670;&#160;</a></span>partition_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::partition_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the partition point of a partitioned range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>mid</code> such that <code>all_of(__first, mid, __pred)</code> and <code>none_of(mid, __last, __pred)</code> are both true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00558">558</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00620_source.html#l00220">std::advance()</a>, and <a class="el" href="a00620_source.html#l00148">std::distance()</a>.</p>

</div>
</div>
<a id="ga695aabc23dc8890aab28a155a13e9fa5" name="ga695aabc23dc8890aab28a155a13e9fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695aabc23dc8890aab28a155a13e9fa5">&#9670;&#160;</a></span>random_shuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Randomly shuffle the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorder the elements in the range <code>[__first, __last)</code> using a random distribution, so that every possible ordering of the sequence is equally likely.</p>
<dl class="deprecated"><dt><b><a class="el" href="a01565.html#_deprecated000009">Deprecated:</a></b></dt><dd>Since C++17, <code>std::random_shuffle</code> is not part of the C++ standard. Use <code>std::shuffle</code> instead, which was introduced in C++11. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04581">4581</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gabf4e555bd94a923ad7d263703b4ab2bc" name="gabf4e555bd94a923ad7d263703b4ab2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4e555bd94a923ad7d263703b4ab2bc">&#9670;&#160;</a></span>random_shuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomNumberGenerator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomNumberGenerator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__rand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the elements of a sequence using a random number generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code>[__first, __last)</code> using <code>__rand</code> to provide a random distribution. Calling <code>__rand(N)</code> for a positive integer <code>N</code> should return a randomly chosen integer from the range <code>[0, N)</code>.</p>
<dl class="deprecated"><dt><b><a class="el" href="a01565.html#_deprecated000010">Deprecated:</a></b></dt><dd>Since C++17, <code>std::random_shuffle</code> is not part of the C++ standard. Use <code>std::shuffle</code> instead, which was introduced in C++11. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04620">4620</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae6ec72c0c6dc0ee8996066b5e50bc472" name="gae6ec72c0c6dc0ee8996066b5e50bc472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ec72c0c6dc0ee8996066b5e50bc472">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements from a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code>__value</code> are removed from the range <code></code>[__first,__last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00836">836</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga86a1b13efaaeecca3d010d942c9ce7a1" name="ga86a1b13efaaeecca3d010d942c9ce7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86a1b13efaaeecca3d010d942c9ce7a1">&#9670;&#160;</a></span>remove_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::remove_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing elements of a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) not equal to <code>__value</code> to the range beginning at <code>__result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00625">625</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga503c001bc1c1d80fe79c7045396faf73" name="ga503c001bc1c1d80fe79c7045396faf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga503c001bc1c1d80fe79c7045396faf73">&#9670;&#160;</a></span>remove_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing elements for which a predicate is true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns false to the range beginning at <code>__result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00659">659</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7bdd7c382561d1d749f4e129658e18a5" name="ga7bdd7c382561d1d749f4e129658e18a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bdd7c382561d1d749f4e129658e18a5">&#9670;&#160;</a></span>remove_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::remove_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove elements from a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code>__pred</code> returns true are removed from the range <code></code>[__first,__last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00870">870</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaaa8637a7be56ce2578b83682a3fdf0ee" name="gaaa8637a7be56ce2578b83682a3fdf0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8637a7be56ce2578b83682a3fdf0ee">&#9670;&#160;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace each occurrence of one value in a sequence with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code>[__first,__last)</code> if <code>*i == __old_value</code> then the assignment <code>*i = __new_value</code> is performed. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04369">4369</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gac84edecb0fb1d0e5cf847a55fd74634f" name="gac84edecb0fb1d0e5cf847a55fd74634f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac84edecb0fb1d0e5cf847a55fd74634f">&#9670;&#160;</a></span>replace_copy_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> _Predicate , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, replacing each value for which a predicate returns true with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The end of the output sequence, <code>__result+</code>(__last-__first).</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) replacing elements for which <code>__pred</code> returns true with <code>__new_value</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03205">3205</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gae26921bd1b038b5ef5dcd40f024c12e2" name="gae26921bd1b038b5ef5dcd40f024c12e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26921bd1b038b5ef5dcd40f024c12e2">&#9670;&#160;</a></span>replace_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate , <a class="el" href="a09261.html">typename</a> _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::replace_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace each value in a sequence for which a predicate returns true with another value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code>[__first,__last)</code> if <code>__pred(*i)</code> is true then the assignment <code>*i = __new_value</code> is performed. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04402">4402</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga8e7ff99a606d89406c0a9f5ec215b041" name="ga8e7ff99a606d89406c0a9f5ec215b041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e7ff99a606d89406c0a9f5ec215b041">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">void</a> std::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code></code>[__first,__last), so that the first element becomes the last etc. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first)/2), <code>reverse()</code> swaps <code>*</code>(__first+i) and <code>*</code>(__last-(i+1)) </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01131">1131</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>, and <a class="el" href="a00464_source.html#l01081">std::__reverse()</a>.</p>

</div>
</div>
<a id="ga20e081bb649e8d217b88c32236e29c02" name="ga20e081bb649e8d217b88c32236e29c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e081bb649e8d217b88c32236e29c02">&#9670;&#160;</a></span>reverse_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BidirectionalIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::reverse_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BidirectionalIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, reversing its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) such that the order of the elements is reversed. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first), <code>reverse_copy()</code> performs the assignment <code>*</code>(__result+(__last-__first)-1-i) = *(__first+i). The ranges <code></code>[__first,__last) and <code></code>[__result,__result+(__last-__first)) must not overlap. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01159">1159</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gabb7937b25672a5ce41d9f5a787fafe35" name="gabb7937b25672a5ce41d9f5a787fafe35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb7937b25672a5ce41d9f5a787fafe35">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotate the elements of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first + (last - middle).</dd></dl>
<p>Rotates the elements of the range <code></code>[__first,__last) by <code></code>(__middle - __first) positions so that the element at <code>__middle</code> is moved to <code>__first</code>, the element at <code>__middle+1</code> is moved to <code>__first+1</code> and so on for each element in the range <code></code>[__first,__last).</p>
<p>This effectively swaps the ranges <code></code>[__first,__middle) and <code></code>[__middle,__last).</p>
<p>Performs <code>*</code>(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first). </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01390">1390</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>, and <a class="el" href="a00464_source.html#l01202">std::__rotate()</a>.</p>

</div>
</div>
<a id="ga46dd8941091696e7b653044da57a11e1" name="ga46dd8941091696e7b653044da57a11e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46dd8941091696e7b653044da57a11e1">&#9670;&#160;</a></span>rotate_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::rotate_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, rotating its elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements of the range <code></code>[__first,__last) to the range beginning at </p><dl class="section return"><dt>Returns</dt><dd>, rotating the copied elements by <code></code>(__middle-__first) positions so that the element at <code>__middle</code> is moved to <code>__result</code>, the element at <code>__middle+1</code> is moved to <code>__result+1</code> and so on for each element in the range <code></code>[__first,__last).</dd></dl>
<p>Performs <code>*</code>(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first). </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01428">1428</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga9c197f83f8612241f91e0a44703fdeaf" name="ga9c197f83f8612241f91e0a44703fdeaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c197f83f8612241f91e0a44703fdeaf">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_RandomAccessIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_UniformRandomNumberGenerator</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> std::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_RandomAccessIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_UniformRandomNumberGenerator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffle the elements of a sequence using a uniform random number generator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__g</td><td>A UniformRandomNumberGenerator (26.5.1.3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code></code>[__first,__last) using <code>__g</code> to provide random numbers. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l03742">3742</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00464_source.html#l03719">std::__gen_two_uniform_ints()</a>.</p>

</div>
</div>
<a id="ga4396b91f26c7aaf0ae150a79ebd965b7" name="ga4396b91f26c7aaf0ae150a79ebd965b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4396b91f26c7aaf0ae150a79ebd965b7">&#9670;&#160;</a></span>stable_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> _Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">_ForwardIterator</a> std::stable_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[first,middle) and false for each <code>i</code> in the range <code></code>[middle,last).</dd></dl>
<p>Performs the same function as <code>partition()</code> with the additional guarantee that the relative ordering of elements in each group is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__pred(x)==__pred(y)</code> will have the same relative ordering after calling <code>stable_partition()</code>. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l01610">1610</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaf1b9a02d1ca7a1622e424d8d912c75bb" name="gaf1b9a02d1ca7a1622e424d8d912c75bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1b9a02d1ca7a1622e424d8d912c75bb">&#9670;&#160;</a></span>swap_ranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator2</a> std::swap_ranges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the elements of two sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator equal to <code>first2+</code>(last1-first1).</dd></dl>
<p>Swaps each element in the range <code></code>[first1,last1) with the corresponding element in the range <code></code>[first2,(last1-first1)). The ranges must not overlap. </p>

<p class="definition">Definition at line <a class="el" href="a00731_source.html#l00204">204</a> of file <a class="el" href="a00731_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a id="ga8c943ad5f85ce0c2f69a074bb42591dd" name="ga8c943ad5f85ce0c2f69a074bb42591dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c943ad5f85ce0c2f69a074bb42591dd">&#9670;&#160;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_UnaryOperation</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_UnaryOperation</a>&#160;</td>
          <td class="paramname"><em>__unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an operation on a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>__result+</code>(__last-__first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=unary_op(*(__first+N)) for each <code>N</code> in the range <code></code>[0,__last-__first).</p>
<p><code>unary_op</code> must not alter its argument. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04298">4298</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gaef5a202b512e1d8a9a6e0a2739290bc1" name="gaef5a202b512e1d8a9a6e0a2739290bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef5a202b512e1d8a9a6e0a2739290bc1">&#9670;&#160;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator2</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryOperation</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator1</a>&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator2</a>&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BinaryOperation</a>&#160;</td>
          <td class="paramname"><em>__binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an operation on corresponding elements of two sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each <code>N</code> in the range <code></code>[0,__last1-__first1).</p>
<p><code>binary_op</code> must not alter either of its arguments. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04336">4336</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="gabedeb9daeefd95379cf49b7e52cafc25" name="gabedeb9daeefd95379cf49b7e52cafc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabedeb9daeefd95379cf49b7e52cafc25">&#9670;&#160;</a></span>unique() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove consecutive duplicate values from a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00939">939</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7a3e26d485c4745ffd5dc1ca26c35a78" name="ga7a3e26d485c4745ffd5dc1ca26c35a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3e26d485c4745ffd5dc1ca26c35a78">&#9670;&#160;</a></span>unique() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_ForwardIterator</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryPredicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_ForwardIterator</a> std::unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_ForwardIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BinaryPredicate</a>&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove consecutive values from a sequence using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code>__binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l00970">970</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a id="ga7bb85887d232506d4c3242cc3fff15a0" name="ga7bb85887d232506d4c3242cc3fff15a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb85887d232506d4c3242cc3fff15a0">&#9670;&#160;</a></span>unique_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing consecutive duplicate values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code>[__first, __last)</code> to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. <code>unique_copy()</code> is stable, so the relative order of elements that are copied is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04502">4502</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>, and <a class="el" href="a00464_source.html#l00995">std::__unique_copy()</a>.</p>

</div>
</div>
<a id="ga1dd1e4d1c78160b672f0c904fd3d2f89" name="ga1dd1e4d1c78160b672f0c904fd3d2f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd1e4d1c78160b672f0c904fd3d2f89">&#9670;&#160;</a></span>unique_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> , <a class="el" href="a09261.html">typename</a> _OutputIterator , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_BinaryPredicate</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _OutputIterator std::unique_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_BinaryPredicate</a>&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a sequence, removing consecutive values using a predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code>[__first, __last)</code> to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements for which <code>__binary_pred</code> returns true. <code>unique_copy()</code> is stable, so the relative order of elements that are copied is unchanged. </p>

<p class="definition">Definition at line <a class="el" href="a00464_source.html#l04543">4543</a> of file <a class="el" href="a00464_source.html">stl_algo.h</a>.</p>

<p class="reference">References <a class="el" href="a00770_source.html#l00239">std::__iterator_category()</a>, and <a class="el" href="a00464_source.html#l00995">std::__unique_copy()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>

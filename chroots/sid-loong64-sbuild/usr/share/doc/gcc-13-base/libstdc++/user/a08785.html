<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a08785.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a08782.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01569.html">Containers</a> &raquo; <a class="el" href="a01572.html">Unordered Associative</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00230_source.html">unordered_set</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adc068faec8f4f9a92d33f2b4f4bbed1d" id="r_adc068faec8f4f9a92d33f2b4f4bbed1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#adc068faec8f4f9a92d33f2b4f4bbed1d">insert_return_type</a> = <a class="el" href="a09261.html">typename</a> _Hashtable::insert_return_type</td></tr>
<tr class="separator:adc068faec8f4f9a92d33f2b4f4bbed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d38bbb127799c47a01713f1fbc239a" id="r_ad1d38bbb127799c47a01713f1fbc239a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ad1d38bbb127799c47a01713f1fbc239a">node_type</a> = <a class="el" href="a09261.html">typename</a> _Hashtable::node_type</td></tr>
<tr class="separator:ad1d38bbb127799c47a01713f1fbc239a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1f83ff00c35e85978dced4fb3ff6772e" id="r_a1f83ff00c35e85978dced4fb3ff6772e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a></td></tr>
<tr class="separator:a1f83ff00c35e85978dced4fb3ff6772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e45fe3da6c5bb759688d5aed9183ff" id="r_a14e45fe3da6c5bb759688d5aed9183ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a></td></tr>
<tr class="separator:a14e45fe3da6c5bb759688d5aed9183ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd37e44a7c63ca0b0b1a61d3d074d7" id="r_a3dcd37e44a7c63ca0b0b1a61d3d074d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::hasher&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a></td></tr>
<tr class="separator:a3dcd37e44a7c63ca0b0b1a61d3d074d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721448c1c7b74465ccfcd51d86a9400c" id="r_a721448c1c7b74465ccfcd51d86a9400c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_equal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a></td></tr>
<tr class="separator:a721448c1c7b74465ccfcd51d86a9400c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bba281b4f65b14513a532e398d37642" id="r_a9bba281b4f65b14513a532e398d37642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a></td></tr>
<tr class="separator:a9bba281b4f65b14513a532e398d37642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af18aca91916dd9537f3c33cd7746b0f4" id="r_af18aca91916dd9537f3c33cd7746b0f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#af18aca91916dd9537f3c33cd7746b0f4">pointer</a></td></tr>
<tr class="separator:af18aca91916dd9537f3c33cd7746b0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c2420ac682e15e195863aecf2bcb8b" id="r_a64c2420ac682e15e195863aecf2bcb8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a64c2420ac682e15e195863aecf2bcb8b">const_pointer</a></td></tr>
<tr class="separator:a64c2420ac682e15e195863aecf2bcb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111a313624cf9219526288500218d406" id="r_a111a313624cf9219526288500218d406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a111a313624cf9219526288500218d406">reference</a></td></tr>
<tr class="separator:a111a313624cf9219526288500218d406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795d0f609bd9032858d61acc386ee11a" id="r_a795d0f609bd9032858d61acc386ee11a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a795d0f609bd9032858d61acc386ee11a">const_reference</a></td></tr>
<tr class="separator:a795d0f609bd9032858d61acc386ee11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fe876578c29d71f3b0e63ae959fc9e" id="r_a02fe876578c29d71f3b0e63ae959fc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a></td></tr>
<tr class="separator:a02fe876578c29d71f3b0e63ae959fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ac106cb24d3c809aa1dac59b508f46" id="r_a77ac106cb24d3c809aa1dac59b508f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a></td></tr>
<tr class="separator:a77ac106cb24d3c809aa1dac59b508f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41daefac0150734553a1b8ae994520e6" id="r_a41daefac0150734553a1b8ae994520e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a41daefac0150734553a1b8ae994520e6">local_iterator</a></td></tr>
<tr class="separator:a41daefac0150734553a1b8ae994520e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71108e3e7466e69cf84def961574aec" id="r_ad71108e3e7466e69cf84def961574aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_local_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a></td></tr>
<tr class="separator:ad71108e3e7466e69cf84def961574aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489606b8c31cc86a461912f292dac389" id="r_a489606b8c31cc86a461912f292dac389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a></td></tr>
<tr class="separator:a489606b8c31cc86a461912f292dac389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78081fffb25f4c7c28a59c7cf4218c51" id="r_a78081fffb25f4c7c28a59c7cf4218c51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">typedef</a> _Hashtable::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a78081fffb25f4c7c28a59c7cf4218c51">difference_type</a></td></tr>
<tr class="separator:a78081fffb25f4c7c28a59c7cf4218c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aace23136ea294ea67dcfe292b896b110" id="r_aace23136ea294ea67dcfe292b896b110"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aace23136ea294ea67dcfe292b896b110">unordered_set</a> ()=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:aace23136ea294ea67dcfe292b896b110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cef2d8f35ac02d862e5f6be404a936" id="r_ab6cef2d8f35ac02d862e5f6be404a936"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:ab6cef2d8f35ac02d862e5f6be404a936"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#ab6cef2d8f35ac02d862e5f6be404a936">unordered_set</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:ab6cef2d8f35ac02d862e5f6be404a936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dca7180189296a96b39b4a9ffd6ec6d" id="r_a2dca7180189296a96b39b4a9ffd6ec6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:a2dca7180189296a96b39b4a9ffd6ec6d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a2dca7180189296a96b39b4a9ffd6ec6d">unordered_set</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a2dca7180189296a96b39b4a9ffd6ec6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbea625ce309dd45648ae7d2d2fae5ad" id="r_adbea625ce309dd45648ae7d2d2fae5ad"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:adbea625ce309dd45648ae7d2d2fae5ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#adbea625ce309dd45648ae7d2d2fae5ad">unordered_set</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n=0, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>(), const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>(), const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a=<a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>())</td></tr>
<tr class="separator:adbea625ce309dd45648ae7d2d2fae5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4ca5472cfe1e526ea39765ef1eba0c" id="r_a5d4ca5472cfe1e526ea39765ef1eba0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a5d4ca5472cfe1e526ea39765ef1eba0c">unordered_set</a> (const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a5d4ca5472cfe1e526ea39765ef1eba0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815061eb273a5be6b49a311e755262e4" id="r_a815061eb273a5be6b49a311e755262e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a815061eb273a5be6b49a311e755262e4">unordered_set</a> (const <a class="el" href="a08785.html">unordered_set</a> &amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:a815061eb273a5be6b49a311e755262e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c6b69b311c66ca7d09013935f0cb09" id="r_ac6c6b69b311c66ca7d09013935f0cb09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ac6c6b69b311c66ca7d09013935f0cb09">unordered_set</a> (const <a class="el" href="a08785.html">unordered_set</a> &amp;<a class="el" href="a09261.html">__uset</a>, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:ac6c6b69b311c66ca7d09013935f0cb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228c39a44620350f4f14664582f460d3" id="r_a228c39a44620350f4f14664582f460d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a228c39a44620350f4f14664582f460d3">unordered_set</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a228c39a44620350f4f14664582f460d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7f8139dc75df3d1dea322ef8118956" id="r_ace7f8139dc75df3d1dea322ef8118956"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ace7f8139dc75df3d1dea322ef8118956">unordered_set</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:ace7f8139dc75df3d1dea322ef8118956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060e030a56e63250f388344e5888702a" id="r_a060e030a56e63250f388344e5888702a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a060e030a56e63250f388344e5888702a">unordered_set</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>, <a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n=0, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>(), const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>(), const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a=<a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>())</td></tr>
<tr class="separator:a060e030a56e63250f388344e5888702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f93223621ef44e8165d5c021793049" id="r_a39f93223621ef44e8165d5c021793049"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a39f93223621ef44e8165d5c021793049">unordered_set</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:a39f93223621ef44e8165d5c021793049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d8a48ea68dbfcdc542737837ad01cf" id="r_af7d8a48ea68dbfcdc542737837ad01cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#af7d8a48ea68dbfcdc542737837ad01cf">unordered_set</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a)</td></tr>
<tr class="separator:af7d8a48ea68dbfcdc542737837ad01cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca41292a5bd6091c80f15eb124d35b05" id="r_aca41292a5bd6091c80f15eb124d35b05"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aca41292a5bd6091c80f15eb124d35b05">unordered_set</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n, const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;<a class="el" href="a09261.html">__hf</a>=<a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>(), const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;<a class="el" href="a09261.html">__eql</a>=<a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>(), const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a=<a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>())</td></tr>
<tr class="separator:aca41292a5bd6091c80f15eb124d35b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d5c94753b23d219090f7dba60fac59" id="r_a56d5c94753b23d219090f7dba60fac59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a56d5c94753b23d219090f7dba60fac59">unordered_set</a> (<a class="el" href="a08785.html">unordered_set</a> &amp;&amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:a56d5c94753b23d219090f7dba60fac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e1d606e1056c72df3f3e8d3b84e745" id="r_aa3e1d606e1056c72df3f3e8d3b84e745"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aa3e1d606e1056c72df3f3e8d3b84e745">unordered_set</a> (<a class="el" href="a08785.html">unordered_set</a> &amp;&amp;<a class="el" href="a09261.html">__uset</a>, const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;__a) noexcept(noexcept(<a class="el" href="a09261.html">_Hashtable</a>(<a class="el" href="a01595.html#ga7b69ea61cf06291d5c8b44e64cf6c280">std::move</a>(__uset._M_h), __a)))</td></tr>
<tr class="separator:aa3e1d606e1056c72df3f3e8d3b84e745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eb98ba94f1c3979662cb677b812648" id="r_a37eb98ba94f1c3979662cb677b812648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a37eb98ba94f1c3979662cb677b812648">bucket</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;<a class="el" href="a09261.html">__key</a>) const</td></tr>
<tr class="separator:a37eb98ba94f1c3979662cb677b812648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5b2e99866a8b463ab6f9fe577f08297" id="r_ae5b2e99866a8b463ab6f9fe577f08297"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ae5b2e99866a8b463ab6f9fe577f08297">bucket_count</a> () const noexcept</td></tr>
<tr class="separator:ae5b2e99866a8b463ab6f9fe577f08297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b62253ea0fd0b5cdfb8149276e1df77" id="r_a1b62253ea0fd0b5cdfb8149276e1df77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a1b62253ea0fd0b5cdfb8149276e1df77">bucket_size</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n) const</td></tr>
<tr class="separator:a1b62253ea0fd0b5cdfb8149276e1df77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc73af25660f155f196c73298073f27" id="r_a4bc73af25660f155f196c73298073f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a4bc73af25660f155f196c73298073f27">cbegin</a> () const noexcept</td></tr>
<tr class="separator:a4bc73af25660f155f196c73298073f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155f3d6e9b8a3a59bb03969355ae5f73" id="r_a155f3d6e9b8a3a59bb03969355ae5f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a155f3d6e9b8a3a59bb03969355ae5f73">cend</a> () const noexcept</td></tr>
<tr class="separator:a155f3d6e9b8a3a59bb03969355ae5f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8049c5e823b2e158de097c48b4bcb0d" id="r_ad8049c5e823b2e158de097c48b4bcb0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ad8049c5e823b2e158de097c48b4bcb0d">clear</a> () noexcept</td></tr>
<tr class="separator:ad8049c5e823b2e158de097c48b4bcb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57d933a9adca62d79de3325c29b8499" id="r_ac57d933a9adca62d79de3325c29b8499"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:ac57d933a9adca62d79de3325c29b8499"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#ac57d933a9adca62d79de3325c29b8499">emplace</a> (<a class="el" href="a09261.html">_Args</a> &amp;&amp;... <a class="el" href="a09261.html">__args</a>)</td></tr>
<tr class="separator:ac57d933a9adca62d79de3325c29b8499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d66aca929c29059391648628f2e250b" id="r_a8d66aca929c29059391648628f2e250b"><td class="memTemplParams" colspan="2">template&lt;typename... _Args&gt; </td></tr>
<tr class="memitem:a8d66aca929c29059391648628f2e250b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a8d66aca929c29059391648628f2e250b">emplace_hint</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a09261.html">__pos</a>, <a class="el" href="a09261.html">_Args</a> &amp;&amp;... <a class="el" href="a09261.html">__args</a>)</td></tr>
<tr class="separator:a8d66aca929c29059391648628f2e250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8d8d725e5ce055255edf7f58bbf726" id="r_a4e8d8d725e5ce055255edf7f58bbf726"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a4e8d8d725e5ce055255edf7f58bbf726">empty</a> () const noexcept</td></tr>
<tr class="separator:a4e8d8d725e5ce055255edf7f58bbf726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac935f6a3b65fe0e5629ada1699c86868" id="r_ac935f6a3b65fe0e5629ada1699c86868"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ac935f6a3b65fe0e5629ada1699c86868">erase</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x)</td></tr>
<tr class="separator:ac935f6a3b65fe0e5629ada1699c86868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7b3eed2fde01c393da9d14f1aa03b9" id="r_acd7b3eed2fde01c393da9d14f1aa03b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#acd7b3eed2fde01c393da9d14f1aa03b9">erase</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> __first, <a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> __last)</td></tr>
<tr class="separator:acd7b3eed2fde01c393da9d14f1aa03b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab931cf66a0cc97d282f0f95b924a5a3" id="r_aab931cf66a0cc97d282f0f95b924a5a3"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aab931cf66a0cc97d282f0f95b924a5a3">extract</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;<a class="el" href="a09261.html">__key</a>)</td></tr>
<tr class="separator:aab931cf66a0cc97d282f0f95b924a5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12fc635b6bc01cf4f8d6d5dcb79ca6f" id="r_af12fc635b6bc01cf4f8d6d5dcb79ca6f"><td class="memItemLeft" align="right" valign="top">node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#af12fc635b6bc01cf4f8d6d5dcb79ca6f">extract</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a09261.html">__pos</a>)</td></tr>
<tr class="separator:af12fc635b6bc01cf4f8d6d5dcb79ca6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6e31142497379c81e5853765ffd9a4" id="r_acf6e31142497379c81e5853765ffd9a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#acf6e31142497379c81e5853765ffd9a4">get_allocator</a> () const noexcept</td></tr>
<tr class="separator:acf6e31142497379c81e5853765ffd9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e199daf0d314f4d3e72f1e694571a8b" id="r_a7e199daf0d314f4d3e72f1e694571a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a7e199daf0d314f4d3e72f1e694571a8b">hash_function</a> () const</td></tr>
<tr class="separator:a7e199daf0d314f4d3e72f1e694571a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d7bdf04f958f040cfd842c6e2d7b6b" id="r_ab8d7bdf04f958f040cfd842c6e2d7b6b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </td></tr>
<tr class="memitem:ab8d7bdf04f958f040cfd842c6e2d7b6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#ab8d7bdf04f958f040cfd842c6e2d7b6b">insert</a> (<a class="el" href="a09261.html">_InputIterator</a> __first, <a class="el" href="a09261.html">_InputIterator</a> __last)</td></tr>
<tr class="separator:ab8d7bdf04f958f040cfd842c6e2d7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d3eed7b5dc6dc89d861a68a2e3b11b" id="r_a74d3eed7b5dc6dc89d861a68a2e3b11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a74d3eed7b5dc6dc89d861a68a2e3b11b">insert</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>, node_type &amp;&amp;<a class="el" href="a09261.html">__nh</a>)</td></tr>
<tr class="separator:a74d3eed7b5dc6dc89d861a68a2e3b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa06dc3ca7393564cf03ce38cbe5d74" id="r_adaa06dc3ca7393564cf03ce38cbe5d74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#adaa06dc3ca7393564cf03ce38cbe5d74">insert</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>)</td></tr>
<tr class="separator:adaa06dc3ca7393564cf03ce38cbe5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a6396f97082b573ccb2898c7cb369f" id="r_a43a6396f97082b573ccb2898c7cb369f"><td class="memItemLeft" align="right" valign="top">insert_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a43a6396f97082b573ccb2898c7cb369f">insert</a> (node_type &amp;&amp;<a class="el" href="a09261.html">__nh</a>)</td></tr>
<tr class="separator:a43a6396f97082b573ccb2898c7cb369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91423e12bcd7c66a7b92c919af9e61a2" id="r_a91423e12bcd7c66a7b92c919af9e61a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a91423e12bcd7c66a7b92c919af9e61a2">key_eq</a> () const</td></tr>
<tr class="separator:a91423e12bcd7c66a7b92c919af9e61a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7300347a4173c3ad35217600d28f50" id="r_a6e7300347a4173c3ad35217600d28f50"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a6e7300347a4173c3ad35217600d28f50">load_factor</a> () const noexcept</td></tr>
<tr class="separator:a6e7300347a4173c3ad35217600d28f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc90e16afa79bd929b49590dc8637b00" id="r_afc90e16afa79bd929b49590dc8637b00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#afc90e16afa79bd929b49590dc8637b00">max_bucket_count</a> () const noexcept</td></tr>
<tr class="separator:afc90e16afa79bd929b49590dc8637b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac182f2597af135950bfc3b1cd09575ec" id="r_ac182f2597af135950bfc3b1cd09575ec"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ac182f2597af135950bfc3b1cd09575ec">max_load_factor</a> () const noexcept</td></tr>
<tr class="separator:ac182f2597af135950bfc3b1cd09575ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086929d624211470ff2b20a0ba23a86d" id="r_a086929d624211470ff2b20a0ba23a86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a086929d624211470ff2b20a0ba23a86d">max_load_factor</a> (float <a class="el" href="a09261.html">__z</a>)</td></tr>
<tr class="separator:a086929d624211470ff2b20a0ba23a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbad50ec9cd24208c2b33f35aa50f371" id="r_afbad50ec9cd24208c2b33f35aa50f371"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#afbad50ec9cd24208c2b33f35aa50f371">max_size</a> () const noexcept</td></tr>
<tr class="separator:afbad50ec9cd24208c2b33f35aa50f371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249af9c6f8f5582ebff2d9e0f0275a6c" id="r_a249af9c6f8f5582ebff2d9e0f0275a6c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:a249af9c6f8f5582ebff2d9e0f0275a6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a249af9c6f8f5582ebff2d9e0f0275a6c">merge</a> (<a class="el" href="a08781.html">unordered_multiset</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:a249af9c6f8f5582ebff2d9e0f0275a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad487108ebc3aa9f1c1fa6501cc4ea5c4" id="r_ad487108ebc3aa9f1c1fa6501cc4ea5c4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:ad487108ebc3aa9f1c1fa6501cc4ea5c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#ad487108ebc3aa9f1c1fa6501cc4ea5c4">merge</a> (<a class="el" href="a08781.html">unordered_multiset</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:ad487108ebc3aa9f1c1fa6501cc4ea5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd790171aaf9a02590ab495d0aeed48" id="r_adcd790171aaf9a02590ab495d0aeed48"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:adcd790171aaf9a02590ab495d0aeed48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#adcd790171aaf9a02590ab495d0aeed48">merge</a> (<a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:adcd790171aaf9a02590ab495d0aeed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9be2cc784d112cc901b07103f95f4b" id="r_a8a9be2cc784d112cc901b07103f95f4b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </td></tr>
<tr class="memitem:a8a9be2cc784d112cc901b07103f95f4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a8a9be2cc784d112cc901b07103f95f4b">merge</a> (<a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;<a class="el" href="a09261.html">__source</a>)</td></tr>
<tr class="separator:a8a9be2cc784d112cc901b07103f95f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84e9c172d095b09b0f89c38e7d61771" id="r_ac84e9c172d095b09b0f89c38e7d61771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html">unordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ac84e9c172d095b09b0f89c38e7d61771">operator=</a> (const <a class="el" href="a08785.html">unordered_set</a> &amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:ac84e9c172d095b09b0f89c38e7d61771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51581c7df608919f98d32f8a523935f9" id="r_a51581c7df608919f98d32f8a523935f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html">unordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a51581c7df608919f98d32f8a523935f9">operator=</a> (<a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt; <a class="el" href="a09261.html">__l</a>)</td></tr>
<tr class="separator:a51581c7df608919f98d32f8a523935f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4218d6c343d8241ebe69ec051c03688" id="r_ab4218d6c343d8241ebe69ec051c03688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html">unordered_set</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ab4218d6c343d8241ebe69ec051c03688">operator=</a> (<a class="el" href="a08785.html">unordered_set</a> &amp;&amp;)=<a class="el" href="a09261.html">default</a></td></tr>
<tr class="separator:ab4218d6c343d8241ebe69ec051c03688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3606a68d349ec1e1e5de56116a39fd" id="r_a6f3606a68d349ec1e1e5de56116a39fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a6f3606a68d349ec1e1e5de56116a39fd">rehash</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n)</td></tr>
<tr class="separator:a6f3606a68d349ec1e1e5de56116a39fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb44171c81ee124bbb21a113ff318530" id="r_aeb44171c81ee124bbb21a113ff318530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aeb44171c81ee124bbb21a113ff318530">reserve</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n)</td></tr>
<tr class="separator:aeb44171c81ee124bbb21a113ff318530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec5052e45a7a980d1968a0805a32dd" id="r_a73ec5052e45a7a980d1968a0805a32dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a73ec5052e45a7a980d1968a0805a32dd">size</a> () const noexcept</td></tr>
<tr class="separator:a73ec5052e45a7a980d1968a0805a32dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688f24d7010519e2bfa001db6fe180e7" id="r_a688f24d7010519e2bfa001db6fe180e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a09261.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a688f24d7010519e2bfa001db6fe180e7">swap</a> (<a class="el" href="a08785.html">unordered_set</a> &amp;__x) noexcept(noexcept(_M_h.swap(__x._M_h)))</td></tr>
<tr class="separator:a688f24d7010519e2bfa001db6fe180e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af200bc1dbcbedeabebd796791807ae31" id="r_af200bc1dbcbedeabebd796791807ae31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#af200bc1dbcbedeabebd796791807ae31">begin</a> () noexcept</td></tr>
<tr class="separator:af200bc1dbcbedeabebd796791807ae31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d563863f9fd94aa7573fecb9c027c23" id="r_a3d563863f9fd94aa7573fecb9c027c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a3d563863f9fd94aa7573fecb9c027c23">begin</a> () const noexcept</td></tr>
<tr class="separator:a3d563863f9fd94aa7573fecb9c027c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa28c45008761a27eecdaeefaab68fa0e" id="r_aa28c45008761a27eecdaeefaab68fa0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aa28c45008761a27eecdaeefaab68fa0e">end</a> () noexcept</td></tr>
<tr class="separator:aa28c45008761a27eecdaeefaab68fa0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ead8905955f0942591a17d70f8405c8" id="r_a9ead8905955f0942591a17d70f8405c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a9ead8905955f0942591a17d70f8405c8">end</a> () const noexcept</td></tr>
<tr class="separator:a9ead8905955f0942591a17d70f8405c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a00481f9d41d75b3a2a2f91f18f7a1816" id="r_a00481f9d41d75b3a2a2f91f18f7a1816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a00481f9d41d75b3a2a2f91f18f7a1816">insert</a> (const <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a00481f9d41d75b3a2a2f91f18f7a1816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c39d419bcdb91617c8203025e2ba0a2" id="r_a6c39d419bcdb91617c8203025e2ba0a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a6c39d419bcdb91617c8203025e2ba0a2">insert</a> (<a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a6c39d419bcdb91617c8203025e2ba0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a6b211cbe01ddf94104caf45b393ae933" id="r_a6b211cbe01ddf94104caf45b393ae933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a6b211cbe01ddf94104caf45b393ae933">insert</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, const <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;__x)</td></tr>
<tr class="separator:a6b211cbe01ddf94104caf45b393ae933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e27a7160d0253be3bc02bf9c2fd4d62" id="r_a9e27a7160d0253be3bc02bf9c2fd4d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a9e27a7160d0253be3bc02bf9c2fd4d62">insert</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a09261.html">__hint</a>, <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&amp;__x)</td></tr>
<tr class="separator:a9e27a7160d0253be3bc02bf9c2fd4d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acef2fe55c494314acad1104ba1488cf6" id="r_acef2fe55c494314acad1104ba1488cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#acef2fe55c494314acad1104ba1488cf6">erase</a> (<a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a09261.html">__position</a>)</td></tr>
<tr class="separator:acef2fe55c494314acad1104ba1488cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5475af91b7b075f1315091b522eacd3e" id="r_a5475af91b7b075f1315091b522eacd3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a5475af91b7b075f1315091b522eacd3e">erase</a> (<a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a09261.html">__position</a>)</td></tr>
<tr class="separator:a5475af91b7b075f1315091b522eacd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af673d30d52e825e4f8da4c8770f0589b" id="r_af673d30d52e825e4f8da4c8770f0589b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#af673d30d52e825e4f8da4c8770f0589b">find</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x)</td></tr>
<tr class="separator:af673d30d52e825e4f8da4c8770f0589b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168c5ad544673d99cf081a8063892dcc" id="r_a168c5ad544673d99cf081a8063892dcc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a168c5ad544673d99cf081a8063892dcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a168c5ad544673d99cf081a8063892dcc">find</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>))</td></tr>
<tr class="separator:a168c5ad544673d99cf081a8063892dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f05b3fd1a72e6b246b0e5ce8d0937cf" id="r_a1f05b3fd1a72e6b246b0e5ce8d0937cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a1f05b3fd1a72e6b246b0e5ce8d0937cf">find</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a1f05b3fd1a72e6b246b0e5ce8d0937cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87aa3e613b917b95bc2672b8ac68c898" id="r_a87aa3e613b917b95bc2672b8ac68c898"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a87aa3e613b917b95bc2672b8ac68c898"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a87aa3e613b917b95bc2672b8ac68c898">find</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>))</td></tr>
<tr class="separator:a87aa3e613b917b95bc2672b8ac68c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1f89dfe5f4807151e3829f060b103efc" id="r_a1f89dfe5f4807151e3829f060b103efc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a1f89dfe5f4807151e3829f060b103efc">count</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a1f89dfe5f4807151e3829f060b103efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c919258c0af8f2c6a6dff19525ee91a" id="r_a3c919258c0af8f2c6a6dff19525ee91a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a3c919258c0af8f2c6a6dff19525ee91a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a3c919258c0af8f2c6a6dff19525ee91a">count</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_count_tr(<a class="el" href="a09261.html">__k</a>))</td></tr>
<tr class="separator:a3c919258c0af8f2c6a6dff19525ee91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac1f6ef40ce608eb2ebec7669c439df7b" id="r_ac1f6ef40ce608eb2ebec7669c439df7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#ac1f6ef40ce608eb2ebec7669c439df7b">contains</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:ac1f6ef40ce608eb2ebec7669c439df7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e1181ffe17cfab9f7ad47122add3bb" id="r_a62e1181ffe17cfab9f7ad47122add3bb"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a62e1181ffe17cfab9f7ad47122add3bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a62e1181ffe17cfab9f7ad47122add3bb">contains</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>), <a class="el" href="a09261.html">void</a>(), <a class="el" href="a09261.html">true</a>)</td></tr>
<tr class="separator:a62e1181ffe17cfab9f7ad47122add3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a861ac271b934d8db08636c1bb8e0fbe6" id="r_a861ac271b934d8db08636c1bb8e0fbe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a861ac271b934d8db08636c1bb8e0fbe6">equal_range</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x)</td></tr>
<tr class="separator:a861ac271b934d8db08636c1bb8e0fbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce34d72f5a41d6a27016d908c5bf67e" id="r_a2ce34d72f5a41d6a27016d908c5bf67e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:a2ce34d72f5a41d6a27016d908c5bf67e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#a2ce34d72f5a41d6a27016d908c5bf67e">equal_range</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(<a class="el" href="a09261.html">__k</a>))</td></tr>
<tr class="separator:a2ce34d72f5a41d6a27016d908c5bf67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ca54fe774c65e64a2f080c8f1062c0" id="r_a67ca54fe774c65e64a2f080c8f1062c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>, <a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a67ca54fe774c65e64a2f080c8f1062c0">equal_range</a> (const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;__x) const</td></tr>
<tr class="separator:a67ca54fe774c65e64a2f080c8f1062c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e67698d1256274ca00afbad62e596a" id="r_ad5e67698d1256274ca00afbad62e596a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </td></tr>
<tr class="memitem:ad5e67698d1256274ca00afbad62e596a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#ad5e67698d1256274ca00afbad62e596a">equal_range</a> (const <a class="el" href="a09261.html">_Kt</a> &amp;<a class="el" href="a09261.html">__k</a>) const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(<a class="el" href="a09261.html">__k</a>))</td></tr>
<tr class="separator:ad5e67698d1256274ca00afbad62e596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aab994b1b759354f0bdd30f6e04b86b68" id="r_aab994b1b759354f0bdd30f6e04b86b68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a41daefac0150734553a1b8ae994520e6">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#aab994b1b759354f0bdd30f6e04b86b68">begin</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n)</td></tr>
<tr class="separator:aab994b1b759354f0bdd30f6e04b86b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28389b5527a3ee6a52adc2ee72e67029" id="r_a28389b5527a3ee6a52adc2ee72e67029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a28389b5527a3ee6a52adc2ee72e67029">begin</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n) const</td></tr>
<tr class="separator:a28389b5527a3ee6a52adc2ee72e67029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a15b1c31e75c9cfd56a4b3f24fe1ce" id="r_a30a15b1c31e75c9cfd56a4b3f24fe1ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a30a15b1c31e75c9cfd56a4b3f24fe1ce">cbegin</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n) const</td></tr>
<tr class="separator:a30a15b1c31e75c9cfd56a4b3f24fe1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70a807c039d620efcfd2b96048c3471a" id="r_a70a807c039d620efcfd2b96048c3471a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#a41daefac0150734553a1b8ae994520e6">local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a70a807c039d620efcfd2b96048c3471a">end</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n)</td></tr>
<tr class="separator:a70a807c039d620efcfd2b96048c3471a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124d7201aeadabc2a92e74fde00ec347" id="r_a124d7201aeadabc2a92e74fde00ec347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a124d7201aeadabc2a92e74fde00ec347">end</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n) const</td></tr>
<tr class="separator:a124d7201aeadabc2a92e74fde00ec347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19f51483e14e3006bf1d6c0c7ec00a" id="r_a5f19f51483e14e3006bf1d6c0c7ec00a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08785.html#a5f19f51483e14e3006bf1d6c0c7ec00a">cend</a> (<a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> __n) const</td></tr>
<tr class="separator:a5f19f51483e14e3006bf1d6c0c7ec00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a80e2d4dd8607efe9b83eabe170e0baae" id="r_a80e2d4dd8607efe9b83eabe170e0baae"><td class="memTemplParams" colspan="2"><a id="a80e2d4dd8607efe9b83eabe170e0baae" name="a80e2d4dd8607efe9b83eabe170e0baae"></a>
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Value1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash1</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred1</a> , <a class="el" href="a09261.html">typename</a> _Alloc1 &gt; </td></tr>
<tr class="memitem:a80e2d4dd8607efe9b83eabe170e0baae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="a08785.html">unordered_set</a>&lt; <a class="el" href="a09261.html">_Value1</a>, <a class="el" href="a09261.html">_Hash1</a>, <a class="el" href="a09261.html">_Pred1</a>, _Alloc1 &gt; &amp;, const <a class="el" href="a08785.html">unordered_set</a>&lt; <a class="el" href="a09261.html">_Value1</a>, <a class="el" href="a09261.html">_Hash1</a>, <a class="el" href="a09261.html">_Pred1</a>, _Alloc1 &gt; &amp;)</td></tr>
<tr class="separator:a80e2d4dd8607efe9b83eabe170e0baae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d" id="r_af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> &gt; </td></tr>
<tr class="memitem:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a09261.html">class</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a08785.html#af0ba6094bfef194c2c3895c5ea1efa6d">std::_Hash_merge_helper</a></td></tr>
<tr class="separator:af0ba6094bfef194c2c3895c5ea1efa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="a09261.html">typename</a> _Value, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a> = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a> = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc = allocator&lt;_Value&gt;&gt;<br />
class std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;</div><p>A standard container composed of unique keys (containing at most one of each key value) in which the elements' keys are the elements themselves. </p>
<dl class="section since"><dt>Since</dt><dd>C++11</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_Value</td><td>Type of key objects. </td></tr>
    <tr><td class="paramname">_Hash</td><td>Hashing function object type, defaults to hash&lt;_Value&gt;.</td></tr>
    <tr><td class="paramname">_Pred</td><td>Predicate function object type, defaults to equal_to&lt;_Value&gt;.</td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;_Key&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, and <a href="tables.html#xx">unordered associative container</a></p>
<p>Base is _Hashtable, dispatched at compile time via template alias __uset_hashtable. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00104">104</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9bba281b4f65b14513a532e398d37642" name="a9bba281b4f65b14513a532e398d37642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bba281b4f65b14513a532e398d37642">&#9670;&#160;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::allocator_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::allocator_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00117">117</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a77ac106cb24d3c809aa1dac59b508f46" name="a77ac106cb24d3c809aa1dac59b508f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ac106cb24d3c809aa1dac59b508f46">&#9670;&#160;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_iterator <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00127">127</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ad71108e3e7466e69cf84def961574aec" name="ad71108e3e7466e69cf84def961574aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71108e3e7466e69cf84def961574aec">&#9670;&#160;</a></span>const_local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_local_iterator <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00129">129</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a64c2420ac682e15e195863aecf2bcb8b" name="a64c2420ac682e15e195863aecf2bcb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c2420ac682e15e195863aecf2bcb8b">&#9670;&#160;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_pointer <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00123">123</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a795d0f609bd9032858d61acc386ee11a" name="a795d0f609bd9032858d61acc386ee11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795d0f609bd9032858d61acc386ee11a">&#9670;&#160;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::const_reference <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::const_reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00125">125</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a78081fffb25f4c7c28a59c7cf4218c51" name="a78081fffb25f4c7c28a59c7cf4218c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78081fffb25f4c7c28a59c7cf4218c51">&#9670;&#160;</a></span>difference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::difference_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::difference_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00131">131</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a3dcd37e44a7c63ca0b0b1a61d3d074d7" name="a3dcd37e44a7c63ca0b0b1a61d3d074d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd37e44a7c63ca0b0b1a61d3d074d7">&#9670;&#160;</a></span>hasher</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::hasher <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::hasher</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00115">115</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="adc068faec8f4f9a92d33f2b4f4bbed1d" name="adc068faec8f4f9a92d33f2b4f4bbed1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc068faec8f4f9a92d33f2b4f4bbed1d">&#9670;&#160;</a></span>insert_return_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">using</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert_return_type =  <a class="el" href="a09261.html">typename</a> _Hashtable::insert_return_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00136">136</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a02fe876578c29d71f3b0e63ae959fc9e" name="a02fe876578c29d71f3b0e63ae959fc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fe876578c29d71f3b0e63ae959fc9e">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::iterator <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00126">126</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a721448c1c7b74465ccfcd51d86a9400c" name="a721448c1c7b74465ccfcd51d86a9400c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721448c1c7b74465ccfcd51d86a9400c">&#9670;&#160;</a></span>key_equal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_equal <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_equal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00116">116</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a1f83ff00c35e85978dced4fb3ff6772e" name="a1f83ff00c35e85978dced4fb3ff6772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f83ff00c35e85978dced4fb3ff6772e">&#9670;&#160;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::key_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00113">113</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a41daefac0150734553a1b8ae994520e6" name="a41daefac0150734553a1b8ae994520e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41daefac0150734553a1b8ae994520e6">&#9670;&#160;</a></span>local_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::local_iterator <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::local_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00128">128</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ad1d38bbb127799c47a01713f1fbc239a" name="ad1d38bbb127799c47a01713f1fbc239a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d38bbb127799c47a01713f1fbc239a">&#9670;&#160;</a></span>node_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">using</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::node_type =  <a class="el" href="a09261.html">typename</a> _Hashtable::node_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00135">135</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="af18aca91916dd9537f3c33cd7746b0f4" name="af18aca91916dd9537f3c33cd7746b0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18aca91916dd9537f3c33cd7746b0f4">&#9670;&#160;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::pointer <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::pointer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00122">122</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a111a313624cf9219526288500218d406" name="a111a313624cf9219526288500218d406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111a313624cf9219526288500218d406">&#9670;&#160;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::reference <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::reference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00124">124</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a489606b8c31cc86a461912f292dac389" name="a489606b8c31cc86a461912f292dac389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489606b8c31cc86a461912f292dac389">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::size_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator-related typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00130">130</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a14e45fe3da6c5bb759688d5aed9183ff" name="a14e45fe3da6c5bb759688d5aed9183ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e45fe3da6c5bb759688d5aed9183ff">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">typedef</a> _Hashtable::value_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public typedefs. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00114">114</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aace23136ea294ea67dcfe292b896b110" name="aace23136ea294ea67dcfe292b896b110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace23136ea294ea67dcfe292b896b110">&#9670;&#160;</a></span>unordered_set() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="aca41292a5bd6091c80f15eb124d35b05" name="aca41292a5bd6091c80f15eb124d35b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca41292a5bd6091c80f15eb124d35b05">&#9670;&#160;</a></span>unordered_set() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor creates no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00152">152</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="adbea625ce309dd45648ae7d2d2fae5ad" name="adbea625ce309dd45648ae7d2d2fae5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbea625ce309dd45648ae7d2d2fae5ad">&#9670;&#160;</a></span>unordered_set() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_set from a range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_set consisting of copies of the elements from [__first,__last). This is linear in N (where N is distance(__first,__last)). </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00173">173</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a815061eb273a5be6b49a311e755262e4" name="a815061eb273a5be6b49a311e755262e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815061eb273a5be6b49a311e755262e4">&#9670;&#160;</a></span>unordered_set() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a56d5c94753b23d219090f7dba60fac59" name="a56d5c94753b23d219090f7dba60fac59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d5c94753b23d219090f7dba60fac59">&#9670;&#160;</a></span>unordered_set() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a id="a5d4ca5472cfe1e526ea39765ef1eba0c" name="a5d4ca5472cfe1e526ea39765ef1eba0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d4ca5472cfe1e526ea39765ef1eba0c">&#9670;&#160;</a></span>unordered_set() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an unordered_set with no elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00192">192</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac6c6b69b311c66ca7d09013935f0cb09" name="ac6c6b69b311c66ca7d09013935f0cb09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c6b69b311c66ca7d09013935f0cb09">&#9670;&#160;</a></span>unordered_set() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__uset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00201">201</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="aa3e1d606e1056c72df3f3e8d3b84e745" name="aa3e1d606e1056c72df3f3e8d3b84e745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e1d606e1056c72df3f3e8d3b84e745">&#9670;&#160;</a></span>unordered_set() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__uset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00211">211</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a060e030a56e63250f388344e5888702a" name="a060e030a56e63250f388344e5888702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060e030a56e63250f388344e5888702a">&#9670;&#160;</a></span>unordered_set() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em> = <code><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> &amp;&#160;</td>
          <td class="paramname"><em>__eql</em> = <code><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds an unordered_set from an initializer_list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list. </td></tr>
    <tr><td class="paramname">__n</td><td>Minimal initial number of buckets. </td></tr>
    <tr><td class="paramname">__hf</td><td>A hash functor. </td></tr>
    <tr><td class="paramname">__eql</td><td>A key equality functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create an unordered_set consisting of copies of the elements in the list. This is linear in N (where N is <em>__l.size()</em>). </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00228">228</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a39f93223621ef44e8165d5c021793049" name="a39f93223621ef44e8165d5c021793049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f93223621ef44e8165d5c021793049">&#9670;&#160;</a></span>unordered_set() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00236">236</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="af7d8a48ea68dbfcdc542737837ad01cf" name="af7d8a48ea68dbfcdc542737837ad01cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d8a48ea68dbfcdc542737837ad01cf">&#9670;&#160;</a></span>unordered_set() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00240">240</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ab6cef2d8f35ac02d862e5f6be404a936" name="ab6cef2d8f35ac02d862e5f6be404a936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cef2d8f35ac02d862e5f6be404a936">&#9670;&#160;</a></span>unordered_set() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00246">246</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a2dca7180189296a96b39b4a9ffd6ec6d" name="a2dca7180189296a96b39b4a9ffd6ec6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dca7180189296a96b39b4a9ffd6ec6d">&#9670;&#160;</a></span>unordered_set() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00253">253</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a228c39a44620350f4f14664582f460d3" name="a228c39a44620350f4f14664582f460d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228c39a44620350f4f14664582f460d3">&#9670;&#160;</a></span>unordered_set() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00259">259</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ace7f8139dc75df3d1dea322ef8118956" name="ace7f8139dc75df3d1dea322ef8118956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7f8139dc75df3d1dea322ef8118956">&#9670;&#160;</a></span>unordered_set() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::unordered_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>__hf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00265">265</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3d563863f9fd94aa7573fecb9c027c23" name="a3d563863f9fd94aa7573fecb9c027c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d563863f9fd94aa7573fecb9c027c23">&#9670;&#160;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00331">331</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="af200bc1dbcbedeabebd796791807ae31" name="af200bc1dbcbedeabebd796791807ae31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af200bc1dbcbedeabebd796791807ae31">&#9670;&#160;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00327">327</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="aab994b1b759354f0bdd30f6e04b86b68" name="aab994b1b759354f0bdd30f6e04b86b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab994b1b759354f0bdd30f6e04b86b68">&#9670;&#160;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a41daefac0150734553a1b8ae994520e6">local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00795">795</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a28389b5527a3ee6a52adc2ee72e67029" name="a28389b5527a3ee6a52adc2ee72e67029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28389b5527a3ee6a52adc2ee72e67029">&#9670;&#160;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00799">799</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a37eb98ba94f1c3979662cb677b812648" name="a37eb98ba94f1c3979662cb677b812648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37eb98ba94f1c3979662cb677b812648">&#9670;&#160;</a></span>bucket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00784">784</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ae5b2e99866a8b463ab6f9fe577f08297" name="ae5b2e99866a8b463ab6f9fe577f08297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5b2e99866a8b463ab6f9fe577f08297">&#9670;&#160;</a></span>bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of buckets of the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00761">761</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a1b62253ea0fd0b5cdfb8149276e1df77" name="a1b62253ea0fd0b5cdfb8149276e1df77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b62253ea0fd0b5cdfb8149276e1df77">&#9670;&#160;</a></span>bucket_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::bucket_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00775">775</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a4bc73af25660f155f196c73298073f27" name="a4bc73af25660f155f196c73298073f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc73af25660f155f196c73298073f27">&#9670;&#160;</a></span>cbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00354">354</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a30a15b1c31e75c9cfd56a4b3f24fe1ce" name="a30a15b1c31e75c9cfd56a4b3f24fe1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a15b1c31e75c9cfd56a4b3f24fe1ce">&#9670;&#160;</a></span>cbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cbegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to the first bucket element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00803">803</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a155f3d6e9b8a3a59bb03969355ae5f73" name="a155f3d6e9b8a3a59bb03969355ae5f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155f3d6e9b8a3a59bb03969355ae5f73">&#9670;&#160;</a></span>cend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00362">362</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a5f19f51483e14e3006bf1d6c0c7ec00a" name="a5f19f51483e14e3006bf1d6c0c7ec00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f19f51483e14e3006bf1d6c0c7ec00a">&#9670;&#160;</a></span>cend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::cend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00823">823</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ad8049c5e823b2e158de097c48b4bcb0d" name="ad8049c5e823b2e158de097c48b4bcb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8049c5e823b2e158de097c48b4bcb0d">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all elements in an unordered_set. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00580">580</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a62e1181ffe17cfab9f7ad47122add3bb" name="a62e1181ffe17cfab9f7ad47122add3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e1181ffe17cfab9f7ad47122add3bb">&#9670;&#160;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>), <a class="el" href="a09261.html">void</a>(), <a class="el" href="a09261.html">true</a>)
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00717">717</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac1f6ef40ce608eb2ebec7669c439df7b" name="ac1f6ef40ce608eb2ebec7669c439df7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f6ef40ce608eb2ebec7669c439df7b">&#9670;&#160;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds whether an element with the given key exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of elements to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if there is any element with the specified key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00712">712</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a3c919258c0af8f2c6a6dff19525ee91a" name="a3c919258c0af8f2c6a6dff19525ee91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c919258c0af8f2c6a6dff19525ee91a">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_count_tr(<a class="el" href="a09261.html">__k</a>))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for unordered_multisets; for unordered_set the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00698">698</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a1f89dfe5f4807151e3829f060b103efc" name="a1f89dfe5f4807151e3829f060b103efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f89dfe5f4807151e3829f060b103efc">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for unordered_multisets; for unordered_set the result will either be 0 (not present) or 1 (present). </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00692">692</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac57d933a9adca62d79de3325c29b8499" name="ac57d933a9adca62d79de3325c29b8499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57d933a9adca62d79de3325c29b8499">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to build and insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__args</td><td>Arguments used to generate an element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to build and insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00384">384</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a8d66aca929c29059391648628f2e250b" name="a8d66aca929c29059391648628f2e250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d66aca929c29059391648628f2e250b">&#9670;&#160;</a></span>emplace_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... _Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::emplace_hint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_Args</a> &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__pos</td><td>An iterator that serves as a hint as to where the element should be inserted. </td></tr>
    <tr><td class="paramname">__args</td><td>Arguments used to generate the element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key equivalent to the one generated from <em>__args</em> (may or may not be the element itself).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument emplace() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>For more on <em>hinting</em>, see: <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a></p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00410">410</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a4e8d8d725e5ce055255edf7f58bbf726" name="a4e8d8d725e5ce055255edf7f58bbf726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8d8d725e5ce055255edf7f58bbf726">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the unordered_set is empty. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00306">306</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a9ead8905955f0942591a17d70f8405c8" name="a9ead8905955f0942591a17d70f8405c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ead8905955f0942591a17d70f8405c8">&#9670;&#160;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00345">345</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="aa28c45008761a27eecdaeefaab68fa0e" name="aa28c45008761a27eecdaeefaab68fa0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28c45008761a27eecdaeefaab68fa0e">&#9670;&#160;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00341">341</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00749_source.html#l00493">std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;::extract()</a>.</p>

</div>
</div>
<a id="a70a807c039d620efcfd2b96048c3471a" name="a70a807c039d620efcfd2b96048c3471a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a807c039d620efcfd2b96048c3471a">&#9670;&#160;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a41daefac0150734553a1b8ae994520e6">local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00815">815</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a124d7201aeadabc2a92e74fde00ec347" name="a124d7201aeadabc2a92e74fde00ec347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124d7201aeadabc2a92e74fde00ec347">&#9670;&#160;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#ad71108e3e7466e69cf84def961574aec">const_local_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only (constant) iterator pointing to one past the last bucket elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The bucket index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read-only local iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00819">819</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a2ce34d72f5a41d6a27016d908c5bf67e" name="a2ce34d72f5a41d6a27016d908c5bf67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce34d72f5a41d6a27016d908c5bf67e">&#9670;&#160;</a></span>equal_range() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(<a class="el" href="a09261.html">__k</a>))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for multisets. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00739">739</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ad5e67698d1256274ca00afbad62e596a" name="ad5e67698d1256274ca00afbad62e596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e67698d1256274ca00afbad62e596a">&#9670;&#160;</a></span>equal_range() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_equal_range_tr(<a class="el" href="a09261.html">__k</a>))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for multisets. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00751">751</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a861ac271b934d8db08636c1bb8e0fbe6" name="a861ac271b934d8db08636c1bb8e0fbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ac271b934d8db08636c1bb8e0fbe6">&#9670;&#160;</a></span>equal_range() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> &gt; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for multisets. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00733">733</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a67ca54fe774c65e64a2f080c8f1062c0" name="a67ca54fe774c65e64a2f080c8f1062c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ca54fe774c65e64a2f080c8f1062c0">&#9670;&#160;</a></span>equal_range() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>, <a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> &gt; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function probably only makes sense for multisets. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00745">745</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac935f6a3b65fe0e5629ada1699c86868" name="ac935f6a3b65fe0e5629ada1699c86868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac935f6a3b65fe0e5629ada1699c86868">&#9670;&#160;</a></span>erase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases elements according to the provided key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements erased.</dd></dl>
<p>This function erases all the elements located by the given key from an unordered_set. For an unordered_set the result of this function can only be 0 (not present) or 1 (present). Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00552">552</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="acd7b3eed2fde01c393da9d14f1aa03b9" name="acd7b3eed2fde01c393da9d14f1aa03b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7b3eed2fde01c393da9d14f1aa03b9">&#9670;&#160;</a></span>erase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a [__first,__last) range of elements from an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be erased. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The iterator <em>__last</em>.</dd></dl>
<p>This function erases a sequence of elements from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00570">570</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="acef2fe55c494314acad1104ba1488cf6" name="acef2fe55c494314acad1104ba1488cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef2fe55c494314acad1104ba1488cf6">&#9670;&#160;</a></span>erase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00530">530</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a5475af91b7b075f1315091b522eacd3e" name="a5475af91b7b075f1315091b522eacd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5475af91b7b075f1315091b522eacd3e">&#9670;&#160;</a></span>erase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases an element from an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, end() is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from an unordered_set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00535">535</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="aab931cf66a0cc97d282f0f95b924a5a3" name="aab931cf66a0cc97d282f0f95b924a5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab931cf66a0cc97d282f0f95b924a5a3">&#9670;&#160;</a></span>extract() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00501">501</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="af12fc635b6bc01cf4f8d6d5dcb79ca6f" name="af12fc635b6bc01cf4f8d6d5dcb79ca6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af12fc635b6bc01cf4f8d6d5dcb79ca6f">&#9670;&#160;</a></span>extract() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">node_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a node. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00493">493</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">References <a class="el" href="a00749_source.html#l00341">std::unordered_set&lt; _Value, _Hash, _Pred, _Alloc &gt;::end()</a>.</p>

</div>
</div>
<a id="a168c5ad544673d99cf081a8063892dcc" name="a168c5ad544673d99cf081a8063892dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168c5ad544673d99cf081a8063892dcc">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00663">663</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a87aa3e613b917b95bc2672b8ac68c898" name="a87aa3e613b917b95bc2672b8ac68c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87aa3e613b917b95bc2672b8ac68c898">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Kt</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">auto</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a09261.html">_Kt</a> &amp;&#160;</td>
          <td class="paramname"><em>__k</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="a09261.html">decltype</a>(_M_h._M_find_tr(<a class="el" href="a09261.html">__k</a>))
	</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00675">675</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="af673d30d52e825e4f8da4c8770f0589b" name="af673d30d52e825e4f8da4c8770f0589b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af673d30d52e825e4f8da4c8770f0589b">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00657">657</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a1f05b3fd1a72e6b246b0e5ce8d0937cf" name="a1f05b3fd1a72e6b246b0e5ce8d0937cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f05b3fd1a72e6b246b0e5ce8d0937cf">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a1f83ff00c35e85978dced4fb3ff6772e">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to locate an element in an unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator pointing to sought-after element, or end() if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code>end()</code> ) iterator. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00669">669</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="acf6e31142497379c81e5853765ffd9a4" name="acf6e31142497379c81e5853765ffd9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6e31142497379c81e5853765ffd9a4">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a9bba281b4f65b14513a532e398d37642">allocator_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the allocator object used by the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00299">299</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a7e199daf0d314f4d3e72f1e694571a8b" name="a7e199daf0d314f4d3e72f1e694571a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e199daf0d314f4d3e72f1e694571a8b">&#9670;&#160;</a></span>hash_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a3dcd37e44a7c63ca0b0b1a61d3d074d7">hasher</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::hash_function </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash functor object with which the unordered_set was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00633">633</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ab8d7bdf04f958f040cfd842c6e2d7b6b" name="ab8d7bdf04f958f040cfd842c6e2d7b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d7bdf04f958f040cfd842c6e2d7b6b">&#9670;&#160;</a></span>insert() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_InputIterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a09261.html">_InputIterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A template function that attempts to insert a range of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00476">476</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a00481f9d41d75b3a2a2f91f18f7a1816" name="a00481f9d41d75b3a2a2f91f18f7a1816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00481f9d41d75b3a2a2f91f18f7a1816">&#9670;&#160;</a></span>insert() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00428">428</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a6b211cbe01ddf94104caf45b393ae933" name="a6b211cbe01ddf94104caf45b393ae933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b211cbe01ddf94104caf45b393ae933">&#9670;&#160;</a></span>insert() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the element should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the element passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>For more on <em>hinting</em>, see: <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a></p>
<p>Insertion requires amortized constant. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00457">457</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a9e27a7160d0253be3bc02bf9c2fd4d62" name="a9e27a7160d0253be3bc02bf9c2fd4d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e27a7160d0253be3bc02bf9c2fd4d62">&#9670;&#160;</a></span>insert() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__hint</td><td>An iterator that serves as a hint as to where the element should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the element passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument insert() does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>For more on <em>hinting</em>, see: <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints">https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints</a></p>
<p>Insertion requires amortized constant. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00461">461</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="a74d3eed7b5dc6dc89d861a68a2e3b11b" name="a74d3eed7b5dc6dc89d861a68a2e3b11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d3eed7b5dc6dc89d861a68a2e3b11b">&#9670;&#160;</a></span>insert() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a77ac106cb24d3c809aa1dac59b508f46">const_iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00511">511</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="adaa06dc3ca7393564cf03ce38cbe5d74" name="adaa06dc3ca7393564cf03ce38cbe5d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa06dc3ca7393564cf03ce38cbe5d74">&#9670;&#160;</a></span>insert() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert a list of elements into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>A std::initializer_list&lt;value_type&gt; of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00487">487</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a43a6396f97082b573ccb2898c7cb369f" name="a43a6396f97082b573ccb2898c7cb369f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a6396f97082b573ccb2898c7cb369f">&#9670;&#160;</a></span>insert() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">insert_return_type <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">node_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>__nh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-insert an extracted node. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00506">506</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="a6c39d419bcdb91617c8203025e2ba0a2" name="a6c39d419bcdb91617c8203025e2ba0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c39d419bcdb91617c8203025e2ba0a2">&#9670;&#160;</a></span>insert() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08457.html">std::pair</a>&lt; <a class="el" href="a08785.html#a02fe876578c29d71f3b0e63ae959fc9e">iterator</a>, bool &gt; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to insert an element into the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to insert an element into the unordered_set. An unordered_set relies on unique keys and thus an element is only inserted if it is not already present in the unordered_set.</p>
<p>Insertion requires amortized constant time. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00432">432</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

<p class="reference">References <a class="el" href="a00527_source.html#l00097">std::move()</a>.</p>

</div>
</div>
<a id="a91423e12bcd7c66a7b92c919af9e61a2" name="a91423e12bcd7c66a7b92c919af9e61a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91423e12bcd7c66a7b92c919af9e61a2">&#9670;&#160;</a></span>key_eq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a721448c1c7b74465ccfcd51d86a9400c">key_equal</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::key_eq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key comparison object with which the unordered_set was constructed. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00639">639</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a6e7300347a4173c3ad35217600d28f50" name="a6e7300347a4173c3ad35217600d28f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7300347a4173c3ad35217600d28f50">&#9670;&#160;</a></span>load_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the average number of elements per bucket. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00831">831</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="afc90e16afa79bd929b49590dc8637b00" name="afc90e16afa79bd929b49590dc8637b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc90e16afa79bd929b49590dc8637b00">&#9670;&#160;</a></span>max_bucket_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_bucket_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of buckets of the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00766">766</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac182f2597af135950bfc3b1cd09575ec" name="ac182f2597af135950bfc3b1cd09575ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac182f2597af135950bfc3b1cd09575ec">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a positive number that the unordered_set tries to keep the load factor less than or equal to. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00837">837</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a086929d624211470ff2b20a0ba23a86d" name="a086929d624211470ff2b20a0ba23a86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086929d624211470ff2b20a0ba23a86d">&#9670;&#160;</a></span>max_load_factor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_load_factor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>__z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the unordered_set maximum load factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__z</td><td>The new maximum load factor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00845">845</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="afbad50ec9cd24208c2b33f35aa50f371" name="afbad50ec9cd24208c2b33f35aa50f371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbad50ec9cd24208c2b33f35aa50f371">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum size of the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00316">316</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a249af9c6f8f5582ebff2d9e0f0275a6c" name="a249af9c6f8f5582ebff2d9e0f0275a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249af9c6f8f5582ebff2d9e0f0275a6c">&#9670;&#160;</a></span>merge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08781.html">unordered_multiset</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00624">624</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ad487108ebc3aa9f1c1fa6501cc4ea5c4" name="ad487108ebc3aa9f1c1fa6501cc4ea5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad487108ebc3aa9f1c1fa6501cc4ea5c4">&#9670;&#160;</a></span>merge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08781.html">unordered_multiset</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00616">616</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="adcd790171aaf9a02590ab495d0aeed48" name="adcd790171aaf9a02590ab495d0aeed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd790171aaf9a02590ab495d0aeed48">&#9670;&#160;</a></span>merge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00611">611</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a8a9be2cc784d112cc901b07103f95f4b" name="a8a9be2cc784d112cc901b07103f95f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9be2cc784d112cc901b07103f95f4b">&#9670;&#160;</a></span>merge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_H2</a> , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_P2</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_H2</a>, <a class="el" href="a09261.html">_P2</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00603">603</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ac84e9c172d095b09b0f89c38e7d61771" name="ac84e9c172d095b09b0f89c38e7d61771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84e9c172d095b09b0f89c38e7d61771">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">unordered_set</a> &amp; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a51581c7df608919f98d32f8a523935f9" name="a51581c7df608919f98d32f8a523935f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51581c7df608919f98d32f8a523935f9">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">unordered_set</a> &amp; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01885.html">initializer_list</a>&lt; <a class="el" href="a08785.html#a14e45fe3da6c5bb759688d5aed9183ff">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unordered_set list assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An initializer_list.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills an unordered_set with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the unordered_set and that the resulting unordered_set's size is the same as the number of elements assigned. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00291">291</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="ab4218d6c343d8241ebe69ec051c03688" name="ab4218d6c343d8241ebe69ec051c03688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4218d6c343d8241ebe69ec051c03688">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html">unordered_set</a> &amp; <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a6f3606a68d349ec1e1e5de56116a39fd" name="a6f3606a68d349ec1e1e5de56116a39fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3606a68d349ec1e1e5de56116a39fd">&#9670;&#160;</a></span>rehash()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>May rehash the unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>The new number of buckets.</td></tr>
  </table>
  </dd>
</dl>
<p>Rehash will occur only if the new number of buckets respect the unordered_set maximum load factor. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00856">856</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="aeb44171c81ee124bbb21a113ff318530" name="aeb44171c81ee124bbb21a113ff318530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb44171c81ee124bbb21a113ff318530">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a>&#160;</td>
          <td class="paramname"><em>__n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the unordered_set for a specified number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__n</td><td>Number of elements required.</td></tr>
  </table>
  </dd>
</dl>
<p>Same as rehash(ceil(n / max_load_factor())). </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00867">867</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a73ec5052e45a7a980d1968a0805a32dd" name="a73ec5052e45a7a980d1968a0805a32dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ec5052e45a7a980d1968a0805a32dd">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a08785.html#a489606b8c31cc86a461912f292dac389">size_type</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the unordered_set. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00311">311</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<a id="a688f24d7010519e2bfa001db6fe180e7" name="a688f24d7010519e2bfa001db6fe180e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688f24d7010519e2bfa001db6fe180e7">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a09261.html">void</a> <a class="el" href="a08785.html">std::unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a08785.html">unordered_set</a>&lt; _Value, <a class="el" href="a09261.html">_Hash</a>, <a class="el" href="a09261.html">_Pred</a>, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps data with another unordered_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>An unordered_set of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two sets in constant time. Note that the global std::swap() function is specialized such that std::swap(s1,s2) will feed to this function. </p>

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00593">593</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af0ba6094bfef194c2c3895c5ea1efa6d" name="af0ba6094bfef194c2c3895c5ea1efa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba6094bfef194c2c3895c5ea1efa6d">&#9670;&#160;</a></span>std::_Hash_merge_helper</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Value , <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Hash</a>  = hash&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> <a class="el" href="a09261.html">_Pred</a>  = equal_to&lt;_Value&gt;, <a class="el" href="a09261.html">typename</a> _Alloc  = allocator&lt;_Value&gt;&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> , <a class="el" href="a09261.html">typename</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend <a class="el" href="a09261.html">class</a> std::_Hash_merge_helper</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00749_source.html#l00599">599</a> of file <a class="el" href="a00749_source.html">unordered_set.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00749_source.html">unordered_set.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a01663.html">std</a></li><li class="navelem"><a class="el" href="a08785.html">unordered_set</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstdc++: Function Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libstdc++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a01614.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Function Objects<div class="ingroups"><a class="el" href="a01595.html">Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Function Objects:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="a01614.svg" width="446" height="424"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:a01619" id="r_a01619"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01619.html">Adaptors for pointers to functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01620" id="r_a01620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01620.html">Adaptors for pointers to members</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01615" id="r_a01615"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01615.html">Arithmetic Function Object Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01626" id="r_a01626"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01626.html">Binder Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01617" id="r_a01617"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01617.html">Boolean Operations Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01616" id="r_a01616"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01616.html">Comparison Classes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01605" id="r_a01605"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01605.html">Hashes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01618" id="r_a01618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01618.html">Negators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08041.html">std::binary_function&lt; _Arg1, _Arg2, _Result &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a07813.html">std::function&lt; _Res(_ArgTypes...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a06333.html">std::move_only_function&lt; _Res(_ArgTypes...) _GLIBCXX_MOF_CV noexcept(_Noex)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a03705.html">std::reference_wrapper&lt; _Tp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a08037.html">std::unary_function&lt; _Arg, _Result &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaea5506b5b1f1188c3a196cec69dbe4d5" id="r_gaea5506b5b1f1188c3a196cec69dbe4d5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Class &gt; </td></tr>
<tr class="memitem:gaea5506b5b1f1188c3a196cec69dbe4d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">_Mem_fn</a>&lt; _Tp _Class::* &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01614.html#gaea5506b5b1f1188c3a196cec69dbe4d5">std::mem_fn</a> (_Tp _Class::*<a class="el" href="a09261.html">__pm</a>) noexcept</td></tr>
<tr class="separator:gaea5506b5b1f1188c3a196cec69dbe4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c2241d49b0de9887e33f399cf119f29" id="r_ga1c2241d49b0de9887e33f399cf119f29"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="a09261.html">typename</a> _Fn &gt; </td></tr>
<tr class="memitem:ga1c2241d49b0de9887e33f399cf119f29"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="a09261.html">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01614.html#ga1c2241d49b0de9887e33f399cf119f29">std::not_fn</a> (_Fn &amp;&amp;<a class="el" href="a09261.html">__fn</a>) noexcept(<a class="el" href="a04021.html">std::is_nothrow_constructible</a>&lt; <a class="el" href="a01593.html#gabe26c12710bb4c683badfaf0a586c5be">std::decay_t</a>&lt; _Fn &gt;, _Fn &amp;&amp; &gt;::value)</td></tr>
<tr class="separator:ga1c2241d49b0de9887e33f399cf119f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Function objects, or <em>functors</em>, are objects with an <code>operator()</code> defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to <em>functors</em>, then, generally we include function pointers in the description as well.</p>
<p>Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.</p>
<p>Two examples taken from the standard itself follow. To perform a by-element addition of two vectors <code>a</code> and <code>b</code> containing <code>double</code>, and put the result in <code>a</code>, use </p><div class="fragment"><div class="line">transform (a.begin(), a.end(), b.begin(), a.begin(), plus&lt;double&gt;());</div>
</div><!-- fragment --><p> To negate every element in <code>a</code>, use </p><div class="fragment"><div class="line">transform(a.begin(), a.end(), a.begin(), negate&lt;double&gt;());</div>
</div><!-- fragment --><p> The addition and negation functions will usually be inlined directly.</p>
<p>An <em>adaptable function object</em> is one which provides nested typedefs <code>result_type</code> and either <code>argument_type</code> (for a unary function) or <code>first_argument_type</code> and <code>second_argument_type</code> (for a binary function). Those typedefs are used by function object adaptors such as <code>bind2nd</code>. The standard library provides two class templates, <code>unary_function</code> and <code>binary_function</code>, which define those typedefs and so can be used as base classes of adaptable function objects.</p>
<p>Since C++11 the use of function object adaptors has been superseded by more powerful tools such as lambda expressions, <code>function&lt;&gt;</code>, and more powerful type deduction (using <code>auto</code> and <code>decltype</code>). The helpers for defining adaptable function objects are deprecated since C++11, and no longer part of the standard library since C++17. However, they are still defined and used by libstdc++ after C++17, as a conforming extension. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaea5506b5b1f1188c3a196cec69dbe4d5" name="gaea5506b5b1f1188c3a196cec69dbe4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5506b5b1f1188c3a196cec69dbe4d5">&#9670;&#160;</a></span>mem_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Tp , <a class="el" href="a09261.html">typename</a> _Class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">_Mem_fn</a>&lt; _Tp _Class::* &gt; std::mem_fn </td>
          <td>(</td>
          <td class="paramtype">_Tp _Class::*&#160;</td>
          <td class="paramname"><em>__pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a function object that forwards to the member pointer pointer <code>pm</code>. </p>
<p>This allows a pointer-to-member to be transformed into a function object that can be called with an object expression as its first argument.</p>
<p>For a pointer-to-data-member the result must be called with exactly one argument, the object expression that would be used as the first operand in a <code>obj.*memptr</code> or <code>objp-&gt;*memptr</code> expression.</p>
<p>For a pointer-to-member-function the result must be called with an object expression and any additional arguments to pass to the member function, as in an expression like <code>(obj.*memfun)(args...)</code> or <code>(objp-&gt;*memfun)(args...)</code>.</p>
<p>The object expression can be a pointer, reference, <code>reference_wrapper</code>, or smart pointer, and the call wrapper will dereference it as needed to apply the pointer-to-member.</p>
<dl class="section since"><dt>Since</dt><dd>C++11 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00095_source.html#l00237">237</a> of file <a class="el" href="a00095_source.html">functional</a>.</p>

</div>
</div>
<a id="ga1c2241d49b0de9887e33f399cf119f29" name="ga1c2241d49b0de9887e33f399cf119f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c2241d49b0de9887e33f399cf119f29">&#9670;&#160;</a></span>not_fn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="a09261.html">typename</a> _Fn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a09261.html">auto</a> std::not_fn </td>
          <td>(</td>
          <td class="paramtype">_Fn &amp;&amp;&#160;</td>
          <td class="paramname"><em>__fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrap a function object to create one that negates its result.</p>
<p>The function template <code>std::not_fn</code> creates a "forwarding call wrapper", which is a function object that wraps another function object and when called, forwards its arguments to the wrapped function object.</p>
<p>The result of invoking the wrapper is the negation (using <code>!</code>) of the wrapped function object.</p>
<dl class="section since"><dt>Since</dt><dd>C++17 </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00095_source.html#l01168">1168</a> of file <a class="el" href="a00095_source.html">functional</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
